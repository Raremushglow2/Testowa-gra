<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<title>Testowa gra</title>
<style>
    body {
        margin: 0;
        font-family: Arial, sans-serif;
        background: #111;
        color: #fff;
        overflow: hidden;
        text-align: center;
    }

    #chooseScreen {
        padding-top: 40px;
    }

    .character {
        display: inline-block;
        cursor: pointer;
        padding: 20px;
        background: #222;
        border-radius: 10px;
        transition: 0.2s;
    }
    .character:hover {
        transform: scale(1.05);
        background: #333;
    }

    #gameContainer {
        display: none;
        position: relative;
        width: 100vw;
        height: 100vh;
        background: #052005; /* ciemna ziele≈Ñ t≈Ça poza pokojem */
        overflow: hidden;
    }

    /* ca≈Çy ≈õwiat w ≈õrodku ‚Äì kamerƒÖ przesuwamy WORLD, nie gameContainer */
    #world {
        position: absolute;
        left: 0;
        top: 0;
    }

    #player {
        position: absolute;
        width: 40px;
        height: 40px;
       background: url("player1.png") center/contain no-repeat;
        z-index: 10;
    }

    .floor {
        position: absolute;
        background: #38a53c; /* jednolita ziele≈Ñ ‚Äì ZERO kratki */
        z-index: 1;
    }
#miniMap {
    position: absolute;
    right: 20px;
    top: 20px;
    width: 150px;
    height: 150px;
    background: rgba(0,0,0,0.4);
    border: 2px solid #fff;
    padding: 5px;
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    gap: 3px;
    z-index: 50;
}

.miniRoom {
    background: #063006;
    border-radius: 3px;
}

.miniRoom.current {
    background: #ffffff;
}

.miniRoom.visited {
    background: #2ecc71;
}

.miniRoom.hasGoal {
    position: relative;
}
#shopMenu {
    max-height: 70vh;
    overflow-y: auto;
}

.miniRoom.hasGoal::after {
    content: "";
    position: absolute;
    width: 8px;
    height: 8px;
    background: yellow;
    border-radius: 50%;
    right: 4px;
    bottom: 4px;
}
/* ‚òÖ‚òÖ‚òÖ HUD ‚Äì na dole ekranu ‚òÖ‚òÖ‚òÖ */

#hud {
    position: absolute;
    width: 100%;
    left: 0;
    bottom: 0;        /* üî• przeniesiony HUD na d√≥≈Ç */
    z-index: 999;
    pointer-events: none;
}

/* HP bar powy≈ºej czar√≥w */
#hpBar {
    width: 300px;
    height: 28px;
    background: #440000;
    border: 2px solid #aa0000;
    border-radius: 6px;
    margin: 0 auto;
    margin-bottom: 110px;   /* üî• HP wy≈ºej */
    position: relative;
}
#hpFill {
    height: 100%;
    width: 100%;
    background: linear-gradient(#ff4444, #cc0000);
    border-radius: 4px;
}

/* Spell bar ‚Äì NA DOLE */
#spellBar {
    position: absolute;
    bottom: 20px;         /* üî• na samym dole */
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 20px;
    pointer-events: auto;
}
.enemy {
    position: absolute;
    width: 40px;
    height: 40px;
    background: url("enemy.png") center/cover no-repeat;
    z-index: 8;
}

.enemyWarning {
    position: absolute;
    width: 200px;
    height: 200px;
    background: rgba(255, 0, 0, 0.25);
    border-radius: 50%;
 
    z-index: 3;
    display: none;
}

.spellSlot {
    width: 80px;
    height: 80px;
    background: #333;
    border: 3px solid #555;
    border-radius: 10px;
    position: relative;
}

.spellSlot.active {
    border-color: #00ccff;
    box-shadow: 0 0 10px #00ccff;
}

.cooldownCover {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.55);
    border-radius: 10px;
    display: none;
}
.spellSlot {
    width: 80px;
    height: 80px;
    background: #333;
    border: 3px solid #555;
    border-radius: 10px;
    position: relative;
    overflow: hidden;             /* üî• NIC nie wyjdzie poza slot */
}

.spellSlot img {
    width: 100%;
    height: 100%;
    object-fit: contain;          /* üî• ikonka dopasowana */
    border-radius: 7px;
    display: block;
}

    .door {
        position: absolute;
        background: #d3a66c;
        border: 2px solid #8b6b43;
        z-index: 5;
    }
.miniRoom.fightRoom {
    position: relative;
}

.miniRoom.fightRoom::after {
    content: "‚öîÔ∏è";
    position: absolute;
    right: 4px;
    bottom: 4px;
    font-size: 14px;
}

#aimLine {
    position: absolute;
    width: 60px;       /* d≈Çugo≈õƒá celownika */
    height: 6px;       /* grubo≈õƒá celownika */
    background: #00c8ff;
    border-radius: 3px;
    z-index: 15;
    transform-origin: left center;  /* obracamy od lewej strony */
    opacity: 0.9;
}
.tree {
    position: absolute;
    width: 160px;
    height: 160px;
    background: url("tree.png") center/cover no-repeat;
    z-index: 4; /* pod graczem, nad pod≈ÇogƒÖ */
    pointer-events: none;
}
.flower {
    position: absolute;
    width: 60px;      /* ma≈Çy kwiatuszek */
    height: 60px;
       background: url("flower.png") center/contain no-repeat;
    z-index: 3;        /* pod graczem, nad pod≈ÇogƒÖ */
    pointer-events: none;
}
#spellMenu {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 250px;
    padding: 20px;
    background: rgba(0,0,0,0.85);
    border: 2px solid white;
    border-radius: 10px;
    display: none;
    z-index: 9999;
}

.slotOption {
    background: #222;
    padding: 10px;
    margin: 10px 0;
    border-radius: 6px;
    cursor: pointer;
}

.slotOption:hover {
    background: #444;
}
#spellMenu {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 320px;
    padding: 20px;
    background: rgba(0,0,0,0.9);
    border: 2px solid white;
    border-radius: 10px;
    display: none;
    z-index: 9999;
    text-align: center;
}

#spellImages {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-bottom: 15px;
}

.menuSpell {
    width: 70px;
    height: 70px;
    background: #222;
    border: 2px solid #555;
    border-radius: 10px;
    cursor: pointer;
}

#spellSlotsChoice {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-bottom: 15px;
}
#goldHUD {
    position: absolute;
    top: 20px;
    left: 20px;
    display: flex;
    align-items: center;
    gap: 10px;
    background: rgba(0,0,0,0.5);
    padding: 8px 12px;
    border: 2px solid #d4b200;
    border-radius: 8px;
    z-index: 9999;
}
.portal {
    position: absolute;
    width: 120px;
    height: 120px;
    background: radial-gradient(circle, #b400ff, #4a0077);
    border-radius: 50%;
    box-shadow: 0 0 25px #b400ff;
    z-index: 20;
    cursor: pointer;
    animation: portalPulse 1.5s infinite ease-in-out;
}

@keyframes portalPulse {
    0%   { transform: scale(1); box-shadow: 0 0 20px #b400ff; }
    50%  { transform: scale(1.15); box-shadow: 0 0 40px #d44cff; }
    100% { transform: scale(1); box-shadow: 0 0 20px #b400ff; }
}
.desertTrader {
    position: absolute;
    width: 40px;   /* taki sam jak gracz */
    height: 40px;
    background: url("scorpiontrader.png") center/contain no-repeat;
    z-index: 9;
    pointer-events: none;
}


#goldIcon {
    width: 32px;
    height: 32px;
}
.trader {
    position: absolute;
    width: 40px;
    height: 40px;
       background: url("trader.png") center/contain no-repeat;
    z-index: 9;
}
.tree2 {
    position: absolute;
    width: 160px;
    height: 160px;
    background: url("tree2.png") center/cover no-repeat;
    z-index: 4;
    pointer-events: none;
}

#shopMenu {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%,-50%);
    width: 260px;
    padding: 20px;
    background: rgba(0,0,0,0.85);
    border: 2px solid gold;
    border-radius: 10px;
    display: none;
    z-index: 99999;
    text-align: center;
}

.shopItem {
    padding: 12px;
    background: #333;
    border: 2px solid #666;
    border-radius: 8px;
    margin: 10px 0;
    cursor: pointer;
}

.shopItem:hover {
    background:#555;
}

#goldAmount {
    font-size: 24px;
    font-weight: bold;
    color: #ffd700;
    text-shadow: 0 0 5px #000;
}

.menuSlot {
    padding: 10px;
    background: #333;
    border: 2px solid #555;
    border-radius: 6px;
    cursor: pointer;
}
#magicBar {
    position: absolute;
    left: 20px;
    bottom: 150px;
    display: flex;
    gap: 10px;
    z-index: 999;
}
.traderPudding {
    position: absolute;
    width: 40px;
    height: 40px;
    background: url("pudding.png") center/contain no-repeat;
    z-index: 9;
}

.magicSlot {
    width: 70px;
    height: 70px;
    background: #333;
    border: 3px solid #7755ff;
    border-radius: 10px;
    overflow: hidden;
}
#magicBar {
    opacity: 0;     /* ukryte na start */
    transition: 0.3s;
}
#itemHUD {
    position: absolute;
    top: 20px;
    left: 120px; /* obok z≈Çota */
    display: flex;
    gap: 8px;
    z-index: 9999;
}

.itemIcon {
    width: 32px;
    height: 32px;
    opacity: 0.75;
    filter: drop-shadow(0 0 4px #000);
}

.magicSlot img {
    width: 100%;
    height: 100%;
    object-fit: contain;
}

    #goal {
        position: absolute;
        width: 24px;
        height: 24px;
        background: yellow;
        border-radius: 50%;
        cursor: pointer;
        z-index: 8;
        display: none;
    }
</style>
</head>
<body>

<!-- EKRAN WYBORU POSTACI -->
<div id="chooseScreen">
    <h1>Wybierz swojƒÖ postaƒá</h1>
    <div id="wizard" class="character">
        <img src="player1.png" width="150" alt="czarodziej">
        <p>Weso≈Çy Czarodziej</p>
    </div>
</div>

<!-- GRA -->
<div id="gameContainer">
    <div id="world">
        <div id="player"></div>
  <div id="aimLine"></div>
        <div id="goal"></div>
    </div>
<div id="miniMap"></div>
<div id="goldHUD">
    <img id="goldIcon" src="gold.png">
    <span id="goldAmount">0</span>
</div>

</div>
<!-- HUD -->
<div id="hud">
    <div id="hpBar">
        <div id="hpFill"></div>
    </div>

    <div id="spellBar">
        <div class="spellSlot" id="slot1">
            <img src="czar1.png">
            <div class="cooldownCover"></div>
        </div>
        <div class="spellSlot" id="slot2">
    <img src="">
    <div class="cooldownCover"></div>
</div>
<div class="spellSlot" id="slot3">
    <img src="">
    <div class="cooldownCover"></div>
</div>
<div id="magicBar">
    <div class="magicSlot" id="magicSlot1">
        <img src="">
    </div>
</div>

    </div>
</div>

<div id="spellMenu">
    <h2>Zmiana uk≈Çadu czar√≥w</h2>

    <p>Kliknij czar ‚Üí potem slot</p>

    <div id="spellImages">
        <img class="menuSpell" id="menuSpell1">
        <img class="menuSpell" id="menuSpell2">
        <img class="menuSpell" id="menuSpell3">
    </div>

    <div id="spellSlotsChoice">
        <button class="menuSlot" data-slot="1">Slot 1</button>
        <button class="menuSlot" data-slot="2">Slot 2</button>
        <button class="menuSlot" data-slot="3">Slot 3</button>
    </div>

    <button onclick="closeSpellMenu()">Zamknij</button>
</div>
<div id="shopMenu">
    <h2>Sklep handlarza</h2>
    <p>Kup czar za 30 z≈Çota:</p>

    <div id="buySpell1" class="shopItem">
        <img src="czar1.png" width="40"><br>
        <b>Nowy czar ‚Äì 30 z≈Çota</b>
    </div>
<div id="buyMirrorSpell" class="shopItem">
    <img src="czar3.png" width="40"><br>
    <b>Lustrzany Portal ‚Äì 50 z≈Çota</b>
</div>

<div id="buyCat" class="shopItem">
    <img src="catfriend.png" width="40">

    <b>Kot ‚Äì 10 z≈Çota</b>
</div>
<div id="buyFireSpell" class="shopItem">
    <img src="czar2.png" width="40"><br>
    <b>Ognista Kula ‚Äì 60 z≈Çota</b>
</div>
<div id="buyHealSpell" class="shopItem">
    <img src="czar4.png" width="40"><br>
    <b>Uzdrowienie ‚Äì 100 z≈Çota</b>
</div>


    <div id="shopSlots"></div>

    <p>Naci≈õnij SPACJƒò aby zamknƒÖƒá</p>
</div>
<div id="itemHUD"></div>
<div id="puddingShop" style="
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    width:260px;
    padding:20px;
    background:rgba(0,0,0,0.85);
    border:2px solid #00ff88;
    border-radius:10px;
    display:none;
    z-index:99999;
    text-align:center;
">
    <h2>Sklep Puddinga</h2>

    <div id="buySlimeAmulet" class="shopItem">
        <img src="amulet_slime.png" width="40"><br>
        <b>Amulet Slima ‚Äì 50 z≈Ç</b><br>
        <small>-10% szybko≈õci wrog√≥w</small>
    </div>
<div id="buyPudding" class="shopItem">
    <img src="hamster.png" width="40">
<br>
    <b>Homik Spokoju ‚Äì 150 z≈Ç</b><br>
    <small>-30% prƒôdko≈õci wrogich pocisk√≥w</small>
</div>
<div id="buyJellySpell" class="shopItem">
    <img src="czar5.png" width="40"><br>
    <b>Puddingowa Tarcza ‚Äì 120 z≈Ç</b><br>
    <small>Spowalnia, ale daje ochronƒô</small>
</div>

    <p>Naci≈õnij SPACJƒò aby zamknƒÖƒá</p>
</div>

<div id="bossBar" style="
    position:absolute;
    top:20px;
    left:50%;
    transform:translateX(-50%);
    width:500px;
    height:30px;
    background:#550000;
    border:3px solid #aa0000;
    border-radius:8px;
    display:none;
    z-index:99999;">
    <div id="bossBarFill" style="
        height:100%;
        width:100%;
        background:#ff3333;
        border-radius:6px;">
    </div>
</div>
<div id="rewardMenu" style="
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%, -50%);
    padding:20px;
    background:rgba(0,0,0,0.85);
    border:3px solid gold;
    border-radius:10px;
    display:none;
    z-index:999999;
    text-align:center;
">
    <h2>Wybierz nagrodƒô</h2>
    <div id="reward1" class="shopItem"></div>
    <div id="reward2" class="shopItem"></div>
 <div id="reward3" class="shopItem"></div>
    <div id="reward4" class="shopItem"></div>
</div>
<div id="desertShop" style="
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    width:260px;
    padding:20px;
    background:rgba(0,0,0,0.85);
    border:2px solid gold;
    border-radius:10px;
    display:none;
    z-index:99999;
    text-align:center;
">
    <h2>Pustynny handlarz</h2>

    <div id="buyPoisonPotion" class="shopItem">
        <img src="poisonpotion.png" width="40"><br>
        <b>Trucizna strza≈Ç√≥w ‚Äì 60 z≈Ç</b><br>
        <small>5% szansy na zatrucie</small>
    </div>

    <p>Naci≈õnij SPACJƒò aby zamknƒÖƒá</p>
</div>




<script>
const chooseScreen   = document.getElementById("chooseScreen");
const gameContainer  = document.getElementById("gameContainer");
const world          = document.getElementById("world");
const player         = document.getElementById("player");
const goalEl         = document.getElementById("goal");
let gold = 0;

/* --- KONFIG --- */
const TILE_SIZE  = 240;   // DU≈ªE kafelki
const ROOM_COLS  = 5;
const ROOM_ROWS  = 5;
const ROOM_W     = TILE_SIZE * ROOM_COLS;
const ROOM_H     = TILE_SIZE * ROOM_ROWS;
let camX = 0;
let camY = 0;
let currentTrader = null;
let shopOpen = false;
let normalTraderSpawned = false;
let puddingTraderSpawned = false;
let normalTraderWillSpawn = false;
let puddingTraderWillSpawn = false;
let slowPlayerTime = 0;
let damageReduction = 0; // 0‚Äì1
let desertTraderWillSpawn = false;
let desertTraderSpawned = false;
let desertTraderRoom = null;

let normalTraderRoom = null;
let puddingTraderRoom = null;
 // {x, y} ‚Äì pok√≥j handlarza
let magicItems = [];
let isTransitioning = false;


let bonusDamage = 0;       // + obra≈ºenia dla czaru 1
let bonusCooldown = 0;     // - cooldown w sekundach
let worldLevel = 1;      // 1‚Äì2 = las, 3 = pustynia
let worldType = "forest"; // forest ‚Üí desert
let poisonTime = 0;
let enemySpeedMultiplier = 1;
let enemyProjectileSpeedMultiplier = 1; // üëà dla puddingu
const ITEM_PUDDING = "hamster.png";



const DUNGEON_W  = 3;     // 3x3 pokoje
const DUNGEON_H  = 3;
// zapis aktualnych czar√≥w
let spellsInSlots = {
    1: "czar1.png",   // jedyny czar jaki masz
    2: null,          // brak czaru
    3: null           // brak czaru
};
let enemyProjectiles = [];


let pickedSpell = null;
const SPELL_COOLDOWNS = {
    "czar1.png": 5000,
    "czar2.png": 7000,
    "czar3.png": 6000,
    "czar4.png": 20000,
"czar5.png": 15000   // 15 sekund

};

/* SZABLONY POKOI */
const roomTemplates = [
    { // pe≈Çny prostokƒÖt
        tiles: [
            [1,1,1,1,1],
            [1,1,1,1,1],
            [1,1,1,1,1],
            [1,1,1,1,1],
            [1,1,1,1,1]
        ]
    },
    { // L z lewej
        tiles: [
            [1,1,1,0,0],
            [1,1,1,0,0],
            [1,1,1,1,1],
            [1,0,0,0,0],
            [1,0,0,0,0]
        ]
    },
    { // L od do≈Çu
        tiles: [
            [0,0,1,1,1],
            [0,0,1,1,1],
            [1,1,1,1,1],
            [1,1,1,0,0],
            [1,1,1,0,0]
        ]
    }
];
let mouseX = 0;
let mouseY = 0;

gameContainer.addEventListener("mousemove", e => {
    mouseX = e.clientX;
    mouseY = e.clientY;
});
const ENEMY_TYPES = [
{
    img: "enemy.png",
    speed: 1.2,
    attackRange: 100,
    attackDamage: 5,
    maxHP: 20,
    warnSize: 200      // dodajemy
},
{
    img: "enemy2.png",
    speed: 2.0,
    attackRange: 160,
    attackDamage: 8,
    maxHP: 30,
    warnSize: 320      // du≈ºo wiƒôkszy okrƒÖg
},
{
    img: "enemy3.png",
    speed: 3.5,         // üî• bardzo szybki
    attackRange: 70,    // üî• ma≈Çy zasiƒôg ataku
    attackDamage: 5,    // mo≈ºesz zmieniƒá
    maxHP: 15,          // üî• twoje wymaganie
    warnSize: 120       // ma≈Çe k√≥≈Çko ostrzegawcze
},
{
    img: "enemy4.png",
    speed: 0,
    attackRange: 1000,
    attackDamage: 8,
    maxHP: 20,
    warnSize: 0,
    isShooter: true,   // ‚≠ê najwa≈ºniejsza linia!
    fireRate: 3500
},
{
    img: "scorpion.png",
    speed: 3.2,
    attackRange: 60,     // ma≈Çy zasiƒôg
    attackDamage: 4,
    maxHP: 30,
    warnSize: 110,
    poison: true         // üëâ specjalny efekt trucizny
},
{
    img: "tumbleweed.png",   // ‚Üê nazwij sw√≥j plik tak jak chcesz
    speed: 1.2,              // wolne turlanie
    attackDamage: 5,
    maxHP: 30,
    tumble: true             // ‚≠ê specjalna flaga ‚Äî tylko ten wr√≥g siƒô odbija
},
{
    img: "antlion.png",
    speed: 0,            // nie rusza siƒô
    attackDamage: 1,     // zadaje 1 dmg
    maxHP: 35,
    isAntlion: true,     // ‚≠ê bardzo wa≈ºna flaga
    pullRange: 250,      // zasiƒôg brƒÖzowego pola przyciƒÖgania
    pullStrength: 0.6,   // si≈Ça ciƒÖgniƒôcia
    damageCooldown: 1500 // 1.5 sekundy na obra≈ºenie
},
{
    img: "plant.png",
    speed: 0,
    attackRange: 1200,
    attackDamage: 8,
    maxHP: 35,          // üî• trochƒô wiƒôcej HP
    warnSize: 0,
    isShooter: true,
    fireRate: 1600      // üî• strzela szybciej ni≈º enemy4 (3500)
},
{
    img: "slime.png",
    speed: 0,
    attackDamage: 15,
    maxHP: 45,
    isSlime: true   // ‚≠ê flaga specjalna
},

{
    img: "slime2.png",
    speed: 0,
    attackDamage: 18,
    maxHP: 55,
    isSlime: true,
    jumpCooldownOverride: 1500 // ‚≠ê 1.5 sekundy
}








];
const RANDOM_SPELL_POOL = [
    "czar1.png",
    "czar2.png",
    "czar3.png",
    "czar4.png",
    "czar5.png"   // üÜï galaretowy czar
];



/* STAN DUNGEONU */
let dungeon = [];     // dungeon[y][x] = {template, hasGoal, goalTile}
let visited = Array.from({length: DUNGEON_H}, () =>
    Array(DUNGEON_W).fill(false)
);
let mirrorControls = false;
let mirrorDungeon = null;   // osobny ≈õwiat lustra
let inMirrorWorld = false;  // czy jeste≈õmy w ≈õwiecie lustra

let currentRoomX = 1;
let currentRoomY = 1;
let lastTime = 0;



let playerX = 0;
let playerY = 0;

let keys = {};
let currentDoors = [];
let currentWalkable = []; // lista prostokƒÖt√≥w z pod≈ÇogƒÖ
let currentTrees = [];
let currentEnemies = [];
let currentFlowers = [];

/* STEROWANIE */
document.addEventListener("keydown", e => { keys[e.key] = true; });
document.addEventListener("keyup",   e => { keys[e.key] = false; });
/* ‚òÖ‚òÖ‚òÖ HP i czary ‚òÖ‚òÖ‚òÖ */

let playerHP = 100;
function updateHP() {
    document.getElementById("hpFill").style.width = playerHP + "%";
}

let selectedSpell = 1;
let spellCooldown = { 1: false, 2: false, 3: false };

// aktywacja slotu
function updateSpellSelection() {
    document.querySelectorAll(".spellSlot").forEach(s => s.classList.remove("active"));
    document.getElementById("slot" + selectedSpell).classList.add("active");
}

updateSpellSelection();
// üî• PRAWY PRZYCISK ‚Äî zmiana slotu czaru
gameContainer.addEventListener("mousedown", e => {
    if (e.button === 2) {  // prawy klik
        selectedSpell++;
        if (selectedSpell > 3) selectedSpell = 1;

        updateSpellSelection();
    }
});


/* ---- WYB√ìR CZARU 1-3 ---- */
document.addEventListener("keydown", e => {
    if (e.key === "1") { selectedSpell = 1; updateSpellSelection(); }
    if (e.key === "2") { selectedSpell = 2; updateSpellSelection(); }
    if (e.key === "3") { selectedSpell = 3; updateSpellSelection(); }
});


function spawnEnemies() {
let possibleEnemies = [];
if (worldType === "forest") {
    possibleEnemies = [0, 1, 2, 3];
}
else if (worldType === "desert") {
    possibleEnemies = [4, 3, 5, 6]; // pustynne
}
else if (worldType === "darkforest") {
    possibleEnemies = [3, 7, 8, 9]; // + fast slime
}





    const room = dungeon[currentRoomY][currentRoomX];

    // ‚òÖ Pok√≥j bossa
    if (room.isBossRoom) {
        if (!room.bossSpawned) {
            spawnBoss();
            room.bossSpawned = true;
        }
        return; // nie spawnujemy zwyk≈Çych wrog√≥w
    }

    currentEnemies = [];

    // ‚òÖ 1. Pok√≥j ju≈º wyczyszczony
    if (room.fightCleared) return;

    // ‚òÖ 2. Losujemy, czy to pok√≥j walki (tylko raz)
    if (room.isFightRoom === false && !room.fightInitialized) {
        room.isFightRoom = Math.random() >= 0.5;
        room.fightInitialized = true;
    }

    // ‚òÖ 3. Je≈õli nie walka ‚Üí wyj≈õcie
    if (!room.isFightRoom) return;



    let enemyCount;

if (worldType === "forest") {
    enemyCount = Math.random() < 0.5 ? 1 : 2;     // las ‚Üí 1 lub 2
} else {
    const r = Math.random();
    if (r < 0.33) enemyCount = 1;
    else if (r < 0.66) enemyCount = 2;
    else enemyCount = 3;                          // pustynia ‚Üí 1,2,3
}



    for (let i = 0; i < enemyCount; i++) {
        const tile = currentWalkable[
            Math.floor(Math.random() * currentWalkable.length)
        ];

        const ex = tile.x1 + TILE_SIZE/2 - 60;
        const ey = tile.y1 + TILE_SIZE/2 - 60;

        // üé≤ losujemy typ wroga
const type = ENEMY_TYPES[
    possibleEnemies[Math.floor(Math.random() * possibleEnemies.length)]
];


const enemy = document.createElement("div");
enemy.className = "enemy";
enemy.style.background = `url("${type.img}") center/cover no-repeat`;
enemy.style.left = ex + "px";
enemy.style.top  = ey + "px";

// === Pasek HP nad wrogiem ===
const hpBar = document.createElement("div");
hpBar.style.position = "absolute";
hpBar.style.width = "40px";
hpBar.style.height = "6px";
hpBar.style.background = "red";
hpBar.style.border = "1px solid #000";
hpBar.style.top = (ey - 10) + "px";
hpBar.style.left = ex + "px";
hpBar.style.zIndex = 9;

// zielone wype≈Çnienie
const hpFill = document.createElement("div");
hpFill.style.width = "100%";   // pe≈Çne HP
hpFill.style.height = "100%";
hpFill.style.background = "lime";

hpBar.appendChild(hpFill);
world.appendChild(hpBar);

      let warn = null;

if (!type.isShooter) {
    warn = document.createElement("div");
    warn.className = "enemyWarning";
    warn.style.width = type.warnSize + "px";
    warn.style.height = type.warnSize + "px";
}


// ustaw pozycjƒô na ≈õrodek przeciwnika
if (warn) {
    warn.style.left = (ex + 20 - type.warnSize/2) + "px";
    warn.style.top  = (ey + 20 - type.warnSize/2) + "px";
    world.appendChild(warn);
}

        world.appendChild(enemy);

 currentEnemies.push({
    el: enemy,
    warn: warn,
    x: ex,
    y: ey,
    type: type,
    hp: type.maxHP,
    hpBar: hpBar,
    hpFill: hpFill,
    attackTimer: 0,
    attackCharging: false,
jumpTimer: 0,
jumpCooldown: type.jumpCooldownOverride || 3000,
  // 3 sekundy
warningEl: null,
jumpTarget: null,
falling: false,

    lastDamageTime: 0   // ‚≠ê Tumbleweed zacznie biƒá!
});




    }
}

function spawnTrees() {
    currentTrees = [];

    const treeCount = Math.floor(Math.random() * 3); // 0‚Äì2 drzewa

    for (let i = 0; i < treeCount; i++) {

        // losowy kafelek pod≈Çogi
        const tile = currentWalkable[Math.floor(Math.random() * currentWalkable.length)];

        const x = tile.x1 + TILE_SIZE/2 - 80; // 160x160 drzewo
        const y = tile.y1 + TILE_SIZE/2 - 80;

        // nie pozwalamy stawiaƒá na drzwiach
        const tooCloseToDoors = currentDoors.some(d => {
            return Math.abs(d.left - x) < 200 && Math.abs(d.top - y) < 200;
        });

        if (tooCloseToDoors) continue;

        const tree = document.createElement("div");
        tree.className = "tree";
        tree.style.left = x + "px";
        tree.style.top = y + "px";

        world.appendChild(tree);

        currentTrees.push({
            el: tree,
            x1: x,
            y1: y,
            x2: x + 160,
            y2: y + 160
        });
    }
}

function castSpell() {
    const slot = selectedSpell;

    if (!spellsInSlots[slot]) return;
    if (spellCooldown[slot]) return;

    fireSpell(slot);

    spellCooldown[slot] = true;

    const cover = document.querySelector(`#slot${slot} .cooldownCover`);
    cover.style.display = "block";

    setTimeout(() => {
        spellCooldown[slot] = false;
        cover.style.display = "none";
    }, 7000);
}





/* ---- NIEBIESKA KULA ---- */
let projectiles = [];

function fireBlueBall() {
    const dirX = (keys["ArrowRight"] || keys["d"]) ? 1 :
                 (keys["ArrowLeft"]  || keys["a"]) ? -1 : 0;

    const dirY = (keys["ArrowDown"]  || keys["s"]) ? 1 :
                 (keys["ArrowUp"]    || keys["w"]) ? -1 : 0;

    const dx = dirX === 0 && dirY === 0 ? 1 : dirX;
    const dy = dirY;

    const startX = playerX + 20;   // ≈õrodek gracza
    const startY = playerY + 20;

    const ball = document.createElement("div");
    ball.style.position = "absolute";
    ball.style.width = "40px";
    ball.style.height = "40px";
    ball.style.background = "url('czar1.png') center/cover no-repeat";
    ball.style.left = startX + "px";
    ball.style.top  = startY + "px";
    ball.style.zIndex = 20;

    world.appendChild(ball);

    projectiles.push({
        el: ball,
        x: startX,
        y: startY,
        dx: dx * 15,
        dy: dy * 15
    });
}


/* Ruch pocisk√≥w */
function updateProjectiles() {
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        p.x += p.dx;
        p.y += p.dy;

        p.el.style.left = p.x + "px";
        p.el.style.top  = p.y + "px";

        // üî• SPRAWD≈π TRAFIENIE W WROGA
        for (let e = currentEnemies.length - 1; e >= 0; e--) {
            const enemy = currentEnemies[e];

            // prostokƒÖt kolizji
            let hit = false;





if (enemy.isBoss) {
// üî• NIE MO≈ªNA UDERZYƒÜ BOSS 5 POD ZIEMIƒÑ
    if (enemy.bossType === "antlionKing" && enemy.burrowed) {
        continue;  // ignoruj pocisk ‚Äì boss jest nietrafialny
    }
    // boss 160√ó160
    hit =
        p.x < enemy.x + 160 &&
        p.x + 40 > enemy.x &&
        p.y < enemy.y + 160 &&
        p.y + 40 > enemy.y;
} else {
    // normalny wr√≥g 40√ó40
    hit =
        p.x < enemy.x + 40 &&
        p.x + 40 > enemy.x &&
        p.y < enemy.y + 40 &&
        p.y + 40 > enemy.y;
}



            if (hit) {
                // zadaj 10 obra≈ºe≈Ñ
   let dmg = 0;

if (p.spellType === "fireball") {
    dmg = 15 + bonusDamage;
}
else if (p.spellType === "czar1") {
    dmg = 10 + bonusDamage;
}
else {
    dmg = 10; // zabezpieczenie
}



    // enemy4 = ro≈õlina, bossType plant = boss4
 if (
    p.spellType === "fireball" && (
        enemy.type === ENEMY_TYPES[3] ||   // enemy4
        enemy.type === ENEMY_TYPES[7] ||   // plant
        enemy.bossType === "plant"         // boss plant
    )
) {
    dmg += 5;
}




enemy.hp -= dmg;
// üß™ TRUCIZNA ‚Äì 5% szansy (czar1 i czar2)
if (
    poisonShots &&
    Math.random() < 0.05 &&
    !enemy.poisoned
) {
    enemy.poisoned = true;
    enemy.poisonTime = 10000; // 10 sekund
    enemy.poisonTick = 0;
}


// ‚ú® efekt trafienia ‚Äî wr√≥g ≈õwieci siƒô na jasno
enemy.el.style.filter = "brightness(2)";

// po 120 ms wraca do normalnego wyglƒÖdu
setTimeout(() => {
    enemy.el.style.filter = "brightness(1)";
}, 120);

if (enemy.isBoss) {
    const percentBoss = enemy.hp / enemy.maxHP;
    document.getElementById("bossBarFill").style.width = (percentBoss * 100) + "%";
}
// aktualizuj pasek HP tylko dla zwyk≈Çych wrog√≥w
if (!enemy.isBoss) {
    const maxHP = enemy.type.maxHP;
    const percent = enemy.hp / maxHP;
    enemy.hpFill.style.width = (percent * 100) + "%";
}



                // usu≈Ñ pocisk
                p.el.remove();
                projectiles.splice(i, 1);

                // je≈õli wr√≥g odpad≈Ç
  if (enemy.hp <= 0) {
// üü° dodaj 10 z≈Çota za ka≈ºdego pokonanego wroga
gold += 10;
updateGold();

if (enemy.isBoss) {
destroyBoss(enemy);

    // oznacz pok√≥j jako uko≈Ñczony
    if (enemy.isBoss) {
    dungeon[currentRoomY][currentRoomX].isBossRoomCleared = true;
    dungeon[currentRoomY][currentRoomX].fightCleared = true;
}

// üî• przej≈õcie do nastƒôpnego ≈õwiata po pokonaniu bossa



    // lustro ‚Üí tylko portal powrotny
    if (inMirrorWorld) {
        spawnReturnPortal(enemy.x + 80, enemy.y + 80);
    }

    // normalny ≈õwiat ‚Üí nagroda + portal
    else {
        showBossRewards(() => {
            spawnPortal(enemy.x + 80, enemy.y + 80);
        });
    }
}




if (enemy.isBoss) {
    document.getElementById("bossBar").style.display = "none";
}

if (enemy.warningEl) enemy.warningEl.remove();

    enemy.el.remove();
if (enemy.field) enemy.field.remove();

    if (enemy.warn) {
    enemy.warn.remove();
}

    if (enemy.hpBar) {
    enemy.hpBar.remove();
}

    currentEnemies.splice(e, 1);

    // ‚òÖ Je≈õli odpad≈Ç ostatni wr√≥g ‚Üí pok√≥j jest na zawsze wyczyszczony
    if (currentEnemies.length === 0) {
        dungeon[currentRoomY][currentRoomX].fightCleared = true;
    }
}



                break; // przejd≈∫ do kolejnego pocisku
            }
        }

        // usu≈Ñ pocisk gdy za daleko
        if (p.x < -5000 || p.x > 5000 || p.y < -5000 || p.y > 5000) {
            p.el.remove();
            projectiles.splice(i, 1);
        }
    }
}


/* KAFELKI PO KT√ìRYCH MO≈ªNA CHODZIƒÜ */
function canWalk(nx, ny) {
    const hit = {
        x1: nx,
        y1: ny,
        x2: nx + 40,
        y2: ny + 40
    };

    for (const tile of currentWalkable) {
        const overlap =
            hit.x1 < tile.x2 &&
            hit.x2 > tile.x1 &&
            hit.y1 < tile.y2 &&
            hit.y2 > tile.y1;

        if (overlap) return true;
    }
    return false;
}


function updateMiniMap() {
    const map = document.getElementById("miniMap");
    map.innerHTML = "";

    for (let y = 0; y < DUNGEON_H; y++) {
        for (let x = 0; x < DUNGEON_W; x++) {
            const cell = document.createElement("div");
            cell.className = "miniRoom";

            // aktualny pok√≥j
            if (x === currentRoomX && y === currentRoomY) {
                cell.classList.add("current");
            }
            // odwiedzone pokoje
            else if (visited[y][x]) {
                cell.classList.add("visited");
            }
            // pok√≥j z celem
            if (dungeon[y][x].hasGoal) {
                cell.classList.add("hasGoal");
            }
if (dungeon[y][x].isFightRoom) {
    cell.classList.add("fightRoom");
}
if (dungeon[y][x].isBossRoom) {
    cell.innerText = "üíÄ";    // emotka
    cell.style.fontSize = "20px";
    cell.style.textAlign = "center";
}

            map.appendChild(cell);
        }
    }
}

/* GENEROWANIE DUNGEONU */
function buildDungeon() {
    dungeon = [];
    for (let y = 0; y < DUNGEON_H; y++) {
        const row = [];
        for (let x = 0; x < DUNGEON_W; x++) {
            const tmplIndex = Math.floor(Math.random() * roomTemplates.length);
    row.push({
    template: tmplIndex,
    hasGoal: false,
    goalTile: null,
    isFightRoom: false,
    fightCleared: false,
    isBossRoom: false,     // ‚òÖ nowo≈õƒá
    bossSpawned: false     // ‚òÖ nowo≈õƒá
});

        }
        dungeon.push(row);
    }

    // losowy pok√≥j z celem
    const gx = Math.floor(Math.random() * DUNGEON_W);
    const gy = Math.floor(Math.random() * DUNGEON_H);
    const tmpl = roomTemplates[dungeon[gy][gx].template].tiles;

    let options = [];
    for (let ry = 0; ry < ROOM_ROWS; ry++) {
        for (let rx = 0; rx < ROOM_COLS; rx++) {
            if (tmpl[ry][rx] === 1) options.push({tx: rx, ty: ry});
        }
    }
    const chosen = options[Math.floor(Math.random() * options.length)];
    dungeon[gy][gx].hasGoal  = true;
    dungeon[gy][gx].goalTile = chosen;
}

/* CZYSZCZENIE POKOJU */
function clearRoomView() {
    document.querySelectorAll(
        ".floor, .door, .trader, .traderPudding, .desertTrader, .tree, .flower, .cactus, .rock"
    ).forEach(el => el.remove());

    currentTrader = null;
    goalEl.style.display = "none";
}







/* POMOCNICZE: czy na brzegu jest pod≈Çoga (do drzwi) */
function hasFloor(tmpl, x, y) {
    return tmpl[y] && tmpl[y][x] === 1;
}

/* WEJ≈öCIE DO KONKRETNEGO POKOJU */
function enterRoom(rx, ry, fromDir = null) {
currentDoors = [];   // USU≈É stare drzwi natychmiast!

    currentRoomX = rx;
    currentRoomY = ry;


visited[ry][rx] = true;
updateMiniMap();

    clearRoomView();

    const roomData = dungeon[ry][rx];
    const tmpl = roomTemplates[roomData.template].tiles;

    // rysujemy pod≈Çogƒô (KA≈ªDY kafelek = jeden kwadrat)
    currentWalkable = [];
    for (let ty = 0; ty < ROOM_ROWS; ty++) {
        for (let tx = 0; tx < ROOM_COLS; tx++) {
            if (tmpl[ty][tx] === 1) {
                const x = tx * TILE_SIZE;
                const y = ty * TILE_SIZE;

                const tile = document.createElement("div");
                tile.className = "floor";
                tile.style.left   = x + "px";
                tile.style.top    = y + "px";
                tile.style.width  = TILE_SIZE + "px";
                tile.style.height = TILE_SIZE + "px";
                world.appendChild(tile);
if (worldType === "desert") {
    tile.style.background = "#e7d27a"; // jasny ≈º√≥≈Çty piasek
}
if (worldType === "darkforest") {
    tile.style.background = "#1f3b1f"; // ciemna ziele≈Ñ
}

                currentWalkable.push({
                    x1: x,
                    y1: y,
                    x2: x + TILE_SIZE,
                    y2: y + TILE_SIZE
                });
            }
        }
    }

    // drzwi ‚Äì tylko je≈õli na brzegu jest pod≈Çoga i istnieje sƒÖsiad
    currentDoors = [];

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DRZWI G√ìRA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if (ry > 0) {
    const col = findEdgeFloor(tmpl, "top");
    if (col !== null) {
        const x = col * TILE_SIZE + TILE_SIZE/2 - 40;
        const y = 0;

        const d = document.createElement("div");
        d.className = "door";
        d.style.width = "80px";
        d.style.height = "24px";
        d.style.left = x + "px";
        d.style.top = y + "px";

        world.appendChild(d);

        currentDoors.push({
            left: x, top: y, width: 80, height: 24,
            targetX: rx,
            targetY: ry - 1,
            enterFrom: "S"
        });
    }
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DRZWI D√ì≈Å ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if (ry < DUNGEON_H - 1) {
    const col = findEdgeFloor(tmpl, "bottom");
    if (col !== null) {
        const x = col * TILE_SIZE + TILE_SIZE/2 - 40;
        const y = ROOM_H - 24;

        const d = document.createElement("div");
        d.className = "door";
        d.style.width = "80px";
        d.style.height = "24px";
        d.style.left = x + "px";
        d.style.top = y + "px";

        world.appendChild(d);

        currentDoors.push({
            left: x, top: y, width: 80, height: 24,
            targetX: rx,
            targetY: ry + 1,
            enterFrom: "N"
        });
    }
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DRZWI LEWO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if (rx > 0) {
    const row = findEdgeFloor(tmpl, "left");
    if (row !== null) {
        const x = 0;
        const y = row * TILE_SIZE + TILE_SIZE/2 - 40;

        const d = document.createElement("div");
        d.className = "door";
        d.style.width = "24px";
        d.style.height = "80px";
        d.style.left = x + "px";
        d.style.top = y + "px";

        world.appendChild(d);

        currentDoors.push({
            left: x, top: y, width: 24, height: 80,
            targetX: rx - 1,
            targetY: ry,
            enterFrom: "E"
        });
    }
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DRZWI PRAWO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if (rx < DUNGEON_W - 1) {
    const row = findEdgeFloor(tmpl, "right");
    if (row !== null) {
        const x = ROOM_W - 24;
        const y = row * TILE_SIZE + TILE_SIZE/2 - 40;

        const d = document.createElement("div");
        d.className = "door";
        d.style.width = "24px";
        d.style.height = "80px";
        d.style.left = x + "px";
        d.style.top = y + "px";

        world.appendChild(d);

        currentDoors.push({
            left: x, top: y, width: 24, height: 80,
            targetX: rx + 1,
            targetY: ry,
            enterFrom: "W"
        });
    }
}



    // Ustaw pozycjƒô gracza w pokoju
switch (fromDir) {
    case "N": // weszli≈õmy z g√≥ry
        playerX = ROOM_W / 2 - 20;
        playerY = TILE_SIZE;
        break;

    case "S": // weszli≈õmy z do≈Çu
        playerX = ROOM_W / 2 - 20;
        playerY = ROOM_H - TILE_SIZE - 40;
        break;

    case "W": // weszli≈õmy z lewej
        playerX = TILE_SIZE;
        playerY = ROOM_H / 2 - 20;
        break;

    case "E": // weszli≈õmy z prawej
        playerX = ROOM_W - TILE_SIZE - 40;
        playerY = ROOM_H / 2 - 20;
        break;

    default: // start gry ‚Äì ≈õrodek pokoju
        playerX = ROOM_W / 2 - 20;
        playerY = ROOM_H / 2 - 20;
}
// üî• TERAZ currentWalkable ju≈º istnieje ‚Äî mo≈ºna szukaƒá bezpiecznej pod≈Çogi
const safe = findNearestWalkableTile(playerX, playerY);
if (safe) {
    playerX = safe.x;
    playerY = safe.y;
}
if (worldType === "forest") {
    spawnTrees();
    spawnFlowers();
}
else if (worldType === "desert") {
    spawnCactus();
    spawnSandRocks();
}
else if (worldType === "darkforest") {
    spawnDarkForestTrees();
}

spawnEnemies();
spawnTrader();


// je≈õli to pok√≥j bossa ‚Üí poka≈º bossbar
if (dungeon[ry][rx].isBossRoom) {
    document.getElementById("bossBar").style.display = "block";
// üî• USTAW HP BOSSBARU NA PE≈ÅNE 100%
const boss = currentEnemies.find(e => e.isBoss);
if (boss) {
    const percent = boss.hp / boss.maxHP;
    document.getElementById("bossBarFill").style.width = (percent * 100) + "%";
}

// je≈õli pok√≥j bossa jest wyczyszczony i nie ma portalu ‚Üí rysujemy go ponownie
if (dungeon[ry][rx].isBossRoom && dungeon[ry][rx].isBossRoomCleared) {

    // sprawdzamy czy portal istnieje
    const portalExists = document.querySelector(".portal");

    if (!portalExists) {
        // DOMY≈öLNA POZYCJA W ≈öRODKU POKOJU
        spawnPortal(ROOM_W / 2, ROOM_H / 2);
    }
}

} else {
    document.getElementById("bossBar").style.display = "none";
}

// üî• od≈õwie≈º minimapƒô po ustaleniu, czy ten pok√≥j jest pokojem walki
updateMiniMap();

updatePlayerPosition();
updateCamera();



    // je≈õli w tym pokoju jest cel
    if (roomData.hasGoal) {
        const t = roomData.goalTile;
        const gx = t.tx * TILE_SIZE + TILE_SIZE/2 - 12;
        const gy = t.ty * TILE_SIZE + TILE_SIZE/2 - 12;
        goalEl.style.left = gx + "px";
        goalEl.style.top  = gy + "px";
        goalEl.style.display = "block";
    }
}

/* WYGRANA */
goalEl.addEventListener("click", () => {
    alert("üéâ Wygra≈Çe≈õ grƒô!");
});

/* RUCH GRACZA I KAMERA */
function updatePlayerPosition() {
    player.style.left = playerX + "px";
    player.style.top  = playerY + "px";
}

function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}

function updateCamera() {
    camX = playerX + 20 - window.innerWidth  / 2;
    camY = playerY + 20 - window.innerHeight / 2;
    world.style.transform = `translate(${-camX}px, ${-camY}px)`;
}


function gameLoop() {
if (isTransitioning) {
    requestAnimationFrame(gameLoop);
    return;
}

    let speed = 6;
if (slowPlayerTime > 0) speed = 4; // 50% wolniej

    const now = performance.now();
    const delta = now - (lastTime || now);
    lastTime = now;

    /* -------------------------------------------------------
       üî• TRUCIZNA ‚Äì dzia≈Ça tylko, je≈õli gracz ≈ºyje!
    -------------------------------------------------------- */
    if (poisonTime > 0) {
        poisonTime -= delta;

        // co ~500ms zabiera HP
        if (Math.floor(poisonTime / 500) % 2 === 0) {
            playerHP -= 0.2;
            updateHP();
        }
    }
if (slowPlayerTime > 0) {
    slowPlayerTime -= delta;
    if (slowPlayerTime <= 0) {
        damageReduction = 0;
    }
}

    /* -------------------------------------------------------
       üî• DETEKCJA ≈öMIERCI GRACZA
       (musi byƒá PRZED WSZYSTKIM!)
    -------------------------------------------------------- */
    if (playerHP <= 0) {
        playerHP = 0;
        updateHP();

        alert("üíÄ Przegra≈Çe≈õ! Spr√≥buj ponownie!");

        location.reload(); // restart gry
        return; // zatrzymuje pƒôtlƒô
    }

    /* -------------------------------------------------------
       üî• RUCH GRACZA
    -------------------------------------------------------- */
    let nx = playerX;
    let ny = playerY;

    if (keys["ArrowUp"] || keys["w"])    ny -= speed;
    if (keys["ArrowDown"] || keys["s"])  ny += speed;
    if (keys["ArrowLeft"] || keys["a"])  nx -= speed;
    if (keys["ArrowRight"] || keys["d"]) nx += speed;

    if (canWalk(nx, ny)) {
        playerX = nx;
        playerY = ny;
    }

    /* -------------------------------------------------------
       üî• AKTUALIZACJE SYSTEM√ìW
    -------------------------------------------------------- */
    updateProjectiles();
    updateAimLine();
    updateEnemyProjectiles();
    updateEnemies(delta);
    updateCatFollower(delta);

    /* -------------------------------------------------------
       üî• DRZWI
    -------------------------------------------------------- */
    for (const door of currentDoors) {

        // gracz musi staƒá na pod≈Çodze
        if (!canWalk(playerX, playerY)) continue;

        if (rectsOverlap(playerX, playerY, 40, 40,
                         door.left, door.top, door.width, door.height)) {

            // blokada przej≈õcia, je≈õli wr√≥g ≈ºyje
            if (enemiesAlive()) continue;

            enterRoom(door.targetX, door.targetY, door.enterFrom);
            break;
        }
    }

    /* -------------------------------------------------------
       üî• KAMERA + GRACZ
    -------------------------------------------------------- */
    updatePlayerPosition();
    updateCamera();

    requestAnimationFrame(gameLoop);
}
/* START GRY PO WYBORZE POSTACI */
document.getElementById("wizard").onclick = () => {
    chooseScreen.style.display = "none";
    gameContainer.style.display = "block";

    buildDungeon();
    chooseBossRoom();
rollTradersForFloor();
    enterRoom(currentRoomX, currentRoomY);
    updateMiniMap();

    gameLoop();   // ‚úî gra startuje dopiero po zbudowaniu ≈õwiata
};



function updateAimLine() {
    // pozycja gracza w przestrzeni ≈õwiata
    const gx = playerX + 20;
    const gy = playerY + 20;

    // pozycja myszy wzglƒôdem ≈õwiata
    const mx = mouseX + camX;
    const my = mouseY + camY;

    const dx = mx - gx;
    const dy = my - gy;

    const angle = Math.atan2(dy, dx);

    // ustaw celownik NA GRACZU
    aimLine.style.left = gx + "px";
    aimLine.style.top  = gy + "px";
    aimLine.style.transform = `rotate(${angle}rad)`;
}



gameContainer.addEventListener("mousedown", e => {
    if (e.button !== 0) return;  // ‚úî tylko LEWY przycisk strzela
    castSpellMouse();
});

function castSpellMouse() {
    const slot = selectedSpell;
    const spell = spellsInSlots[slot];

    if (!spell) return;
    if (spellCooldown[slot]) return;

    // --- RZUCENIE CZARU ---
    if (spell === "czar4.png") {
        // leczenie
        playerHP = Math.min(playerHP + 15, 100);
        updateHP();
    }
    else if (spell === "czar2.png") {
        fireFireSpell(slot);
    }
    else if (spell === "czar3.png") {
        createMirrorPortal();
    }
else if (spell === "czar5.png") {
    // Galaretowa Tarcza
    slowPlayerTime = 5000;     // 5 sekund
    damageReduction = 0.35;    // 25% mniej obra≈ºe≈Ñ
}

    else {
        fireSpellTowardMouse(slot); // czar 1
    }

    // --- COOLDOWN ---
    let cd = SPELL_COOLDOWNS[spell];

    // üî• ulepszenie cooldownu DZIA≈ÅA TYLKO na czary 1‚Äì3
    if (spell !== "czar4.png") {
        cd -= bonusCooldown * 1000;
        if (cd < 2000) cd = 2000;
    }

    spellCooldown[slot] = true;

    const cover = document.querySelector(`#slot${slot} .cooldownCover`);
    cover.style.display = "block";

    setTimeout(() => {
        spellCooldown[slot] = false;
        cover.style.display = "none";
    }, cd);
}






function fireBlueBallTowardMouse() {
    const gx = playerX + 20;
    const gy = playerY + 20;

    const mx = mouseX + camX;
    const my = mouseY + camY;

    const dx = mx - gx;
    const dy = my - gy;

    const len = Math.hypot(dx, dy);
    const vx = (dx / len) * 8;
    const vy = (dy / len) * 8;

    const ball = document.createElement("img");
    ball.src = "pocisk1.png";
    ball.style.position = "absolute";

    const w = 120;
    const h = 60;

    ball.style.width = w + "px";
    ball.style.height = h + "px";

    // üî• POPRAWKA ‚Äî ustaw pocisk tak, aby ≈õrodek by≈Ç na graczu
    ball.style.left = (gx - w/2) + "px";
    ball.style.top  = (gy - h/2) + "px";

    ball.style.transform = `rotate(${Math.atan2(vy, vx)}rad)`;
    ball.style.zIndex = 20;
    world.appendChild(ball);

    projectiles.push({
        el: ball,
        x: gx - w/2,
        y: gy - h/2,
        dx: vx,
        dy: vy
    });
}



function findNearestWalkableTile(x, y) {
    let best = null;
    let bestDist = Infinity;

    for (const t of currentWalkable) {
        const cx = (t.x1 + t.x2) / 2;
        const cy = (t.y1 + t.y2) / 2;

        const dx = cx - x;
        const dy = cy - y;
        const dist = dx*dx + dy*dy;

        if (dist < bestDist) {
            bestDist = dist;
            best = { x: cx - 20, y: cy - 20 }; // -20 to ≈õrodek gracza
        }
    }

    return best;
}
function enemiesAlive() {
    return currentEnemies.length > 0;
}

function updateEnemies(delta) {
    for (let i = currentEnemies.length - 1; i >= 0; i--) {
        const e = currentEnemies[i];
// üß™ TRUCIZNA
if (e.poisoned) {
    e.poisonTime -= delta;
    e.poisonTick = (e.poisonTick || 0) + delta;

    if (e.poisonTick >= 1000) {
        e.poisonTick = 0;
        e.hp -= 1;

        // zielony b≈Çysk
        e.el.style.filter = "hue-rotate(90deg) brightness(1.4)";
        setTimeout(() => {
            if (e.el) e.el.style.filter = "brightness(1)";
        }, 120);

        // aktualizacja HP bara
        if (e.isBoss) {
            const percent = e.hp / e.maxHP;
            document.getElementById("bossBarFill").style.width = (percent * 100) + "%";
        } else if (e.hpFill) {
            const percent = e.hp / e.type.maxHP;
            e.hpFill.style.width = (percent * 100) + "%";
        }
    }

    if (e.poisonTime <= 0) {
        e.poisoned = false;
    }
}

if (e.dead) continue;   // üîí NIC nie dzia≈Ça po pokonaniu


        // üî• JE≈öLI ELEMENT DOM NIE ISTNIEJE ‚Üí USU≈É WROGA
        if (!e.el || !e.el.parentNode) {
            currentEnemies.splice(i, 1);
            continue;
        }




        /* =======================================================
           1. BOSS ‚Äì musi byƒá obs≈Çu≈ºony jako pierwszy!
        ======================================================= */
       if (e.isBoss) {

    if (e.dead) continue;   // ‚≠ê BLOKADA PO Pokonaniu

    updateBossLogic(e, delta);
    continue; 
}


        /* =======================================================
           2. STRZELAJƒÑCY WR√ìG ‚Äì osobna logika
        ======================================================= */
        if (e.type.isShooter) {
            const dx = playerX - e.x;
            const dy = playerY - e.y;
            const dist = Math.hypot(dx, dy);

            // strzela tylko je≈õli gracz w zasiƒôgu
            if (dist < e.type.attackRange) {
                e.lastShot = (e.lastShot || 0) + delta;

                if (e.lastShot >= e.type.fireRate) {
                    e.lastShot = 0;
                    enemyFireProjectile(e);
                }
            }

            continue; 
        }
// ‚≠ê TUMBLEWEED ‚Äì ruch i odbijanie
if (e.type.tumble) {

    // je≈õli pierwszy raz ‚Äî nadaj mu losowy kierunek
    if (!e.vx) {
        const angle = Math.random() * Math.PI * 2;
        e.vx = Math.cos(angle) * e.type.speed;
        e.vy = Math.sin(angle) * e.type.speed;
    }

    // ruch
    e.x += e.vx;
    e.y += e.vy;

    // odbicia od ≈õcian pokoju 5√ó5 TILE_SIZE
    const roomW = ROOM_COLS * TILE_SIZE;
    const roomH = ROOM_ROWS * TILE_SIZE;
if (e.x <= 0) {
    e.x = 0;
    e.vx *= -1;
} else if (e.x >= roomW - 40) {
    e.x = roomW - 40;
    e.vx *= -1;
}

if (e.y <= 0) {
    e.y = 0;
    e.vy *= -1;
} else if (e.y >= roomH - 40) {
    e.y = roomH - 40;
    e.vy *= -1;
}


    // ustaw pozycjƒô
    e.el.style.left = e.x + "px";
    e.el.style.top  = e.y + "px";

    // pasek HP
    if (e.hpBar) {
        e.hpBar.style.left = e.x + "px";
        e.hpBar.style.top  = (e.y - 10) + "px";
    }

 // ‚≠ê zadaje obra≈ºenia tylko raz na sekundƒô
if (
    e.x < playerX + 40 &&
    e.x + 40 > playerX &&
    e.y < playerY + 40 &&
    e.y + 40 > playerY
) {
    const now = performance.now();
    if (now - e.lastDamageTime >= 1000) {  // 1 sekunda odstƒôpu
        playerHP -= e.type.attackDamage * (1 - damageReduction);

        updateHP();
        e.lastDamageTime = now;
    }
}


    continue; // bardzo wa≈ºne ‚Äî nie stosuj logiki innych wrog√≥w
}
/* =======================================================
   üü¢ SLIME ‚Äì skok z g√≥ry
======================================================= */
if (e.type.isSlime) {

    if (isTransitioning) continue;


    e.jumpTimer += delta;

    // 1Ô∏è‚É£ WYZNACZ CEL I POKA≈ª OSTRZE≈ªENIE
    if (!e.falling && !e.warningEl && e.jumpTimer >= e.jumpCooldown) {

        e.jumpTimer = 0;

        const tx = playerX + 20;
        const ty = playerY + 20;

        e.jumpTarget = { x: tx, y: ty };

        const warn = document.createElement("div");
        warn.style.position = "absolute";
        warn.style.width = "120px";
        warn.style.height = "120px";
        warn.style.borderRadius = "50%";
        warn.style.background = "rgba(255,0,0,0.35)";
        warn.style.left = (tx - 60) + "px";
        warn.style.top  = (ty - 60) + "px";
        warn.style.zIndex = 2;

        world.appendChild(warn);
        e.warningEl = warn;

        // 2Ô∏è‚É£ PO 3 SEKUNDACH ‚Äî SPADEK
 e.jumpTimeout = setTimeout(() => {

    if (e.dead || !e.el || !e.el.parentNode) {
        if (e.warningEl) e.warningEl.remove();
        return;
    }

    e.falling = true;
    e.x = e.jumpTarget.x - 20;
    e.y = -200;
    e.el.style.left = e.x + "px";
    e.el.style.top  = e.y + "px";

    if (e.warningEl) {
        e.warningEl.remove();
        e.warningEl = null;
    }

}, 3000);

    }

    // 3Ô∏è‚É£ SPADEK Z G√ìRY
    if (e.falling) {
        e.y += 18;

        e.el.style.left = e.x + "px";
        e.el.style.top  = e.y + "px";
if (e.hpBar) {
    e.hpBar.style.left = e.x + "px";
    e.hpBar.style.top  = (e.y - 10) + "px";
}

        // dotar≈Ç do celu
        if (e.y >= e.jumpTarget.y - 20) {
            e.falling = false;

            // üî• obra≈ºenia przy lƒÖdowaniu
            if (
                rectsOverlap(
                    e.x, e.y, 40, 40,
                    playerX, playerY, 40, 40
                )
            ) {
                playerHP -= e.type.attackDamage * (1 - damageReduction);

                updateHP();
            }
        }
    }

    continue; // ‚ùó NIE wykonuj innej logiki wroga
}

// ‚≠ê ANTLION ‚Äì pole przyciƒÖgania (wr√≥g 40√ó40)
if (e.type.isAntlion) {

    const gx = playerX + 20;   // ≈õrodek gracza
    const gy = playerY + 20;
    const ex = e.x + 20;       // ≈õrodek antliona (40√ó40 ‚Üí +20)
    const ey = e.y + 20;

    const dx = gx - ex;
    const dy = gy - ey;
    const dist = Math.hypot(dx, dy);

    // --- rysowanie pola piasku ---
    if (!e.field) {
        const f = document.createElement("div");
        f.style.position = "absolute";
        f.style.width = (e.type.pullRange * 2) + "px";
        f.style.height = (e.type.pullRange * 2) + "px";
        f.style.borderRadius = "50%";
        f.style.background = "rgba(139, 69, 19, 0.25)";
        f.style.left = (ex - e.type.pullRange) + "px";
        f.style.top  = (ey - e.type.pullRange) + "px";
        f.style.zIndex = 2;
        world.appendChild(f);
        e.field = f;
    }

    // aktualizacja pozycji pola
    e.field.style.left = (ex - e.type.pullRange) + "px";
    e.field.style.top  = (ey - e.type.pullRange) + "px";

    // --- PRZYCIƒÑGANIE GRACZA ---
    if (dist < e.type.pullRange) {

        const pullX = (dx / dist) * e.type.pullStrength;
        const pullY = (dy / dist) * e.type.pullStrength;

        playerX += pullX;
        playerY += pullY;
        updatePlayerPosition();

        // obra≈ºenia 1 dmg co 1.5s
        const now = performance.now();
        e.lastDmg = e.lastDmg || 0;

        if (now - e.lastDmg >= e.type.damageCooldown) {
            playerHP -= e.type.attackDamage * (1 - damageReduction);

            updateHP();
            e.lastDmg = now;
        }
    }

    continue; // koniec logiki antliona
}


        /* =======================================================
           3. NORMALNY WR√ìG
        ======================================================= */

        // wektor do gracza
        const dx = playerX - e.x;
        const dy = playerY - e.y;
        const dist = Math.hypot(dx, dy);



        // ruch
        if (!e.attackCharging) {
            const speed = e.type.speed * enemySpeedMultiplier;

            e.x += (dx / dist) * speed;
            e.y += (dy / dist) * speed;

            e.el.style.left = e.x + "px";
            e.el.style.top  = e.y + "px";

            if (e.hpBar) {
                e.hpBar.style.left = e.x + "px";
                e.hpBar.style.top  = (e.y - 10) + "px";
            }
        }

        // WARNS ‚Äì tylko je≈õli wr√≥g ma warn
        if (e.warn) {
            e.warn.style.left = (e.x + 20 - e.type.warnSize / 2) + "px";
            e.warn.style.top  = (e.y + 20 - e.type.warnSize / 2) + "px";
        }

        // rozpoczƒôcie ≈Çadowania ataku wrƒôcz
        if (dist < e.type.attackRange && !e.attackCharging) {
            e.attackCharging = true;
            e.attackTimer = 0;

            if (e.warn) e.warn.style.display = "block";
        }

        // ≈Çadowanie ataku
   if (e.attackCharging) {
    e.attackTimer += delta;

    // ‚≠ê szybki czas ≈Çadowania tylko dla enemy3
    const attackTime = (e.type === ENEMY_TYPES[2]) ? 600 : 1500;

    if (e.attackTimer >= attackTime) {
        e.attackCharging = false;
        if (e.warn) e.warn.style.display = "none";

        const gx = playerX + 20;
        const gy = playerY + 20;
        const ex = e.x + 20;
        const ey = e.y + 20;

        if (Math.hypot(gx - ex, gy - ey) < e.type.attackRange) {
            playerHP -= e.type.attackDamage * (1 - damageReduction);


if (e.type.poison) {
    poisonTime = 5000; // 5 sekund
}

updateHP();

        }
    }


        }
    }
}
function avoidTrees(e) {
    for (const t of currentTrees) {
        const tx = t.x1 + 80; // ≈õrodek drzewa
        const ty = t.y1 + 80;

        const dx = e.x - tx;
        const dy = e.y - ty;
        const dist = Math.hypot(dx, dy);

        // je≈õli wr√≥g jest zbyt blisko drzewa ‚Üí delikatnie odpychamy
        if (dist < 140) {
            const force = (140 - dist) * 0.03;
            e.x += (dx / dist) * force;
            e.y += (dy / dist) * force;
        }
    }
}
function spawnFlowers() {
    currentFlowers = [];

    // 2‚Äì5 kwiatk√≥w w pokoju
    const flowerCount = Math.floor(Math.random() * 4) + 2;

    for (let i = 0; i < flowerCount; i++) {

        // losowy kafelek pod≈Çogi
        const tile = currentWalkable[Math.floor(Math.random() * currentWalkable.length)];

        const x = tile.x1 + TILE_SIZE/2 - 30; // ≈õrodek kafelka
        const y = tile.y1 + TILE_SIZE/2 - 30;

        // nie pozwalamy generowaƒá na drzwiach
        const tooCloseToDoors = currentDoors.some(d => {
            return Math.abs(d.left - x) < 120 && Math.abs(d.top - y) < 120;
        });
        if (tooCloseToDoors) continue;

        const flower = document.createElement("div");
        flower.className = "flower";
        flower.style.left = x + "px";
        flower.style.top  = y + "px";

        world.appendChild(flower);

        currentFlowers.push({
            el: flower,
            x1: x,
            y1: y,
            x2: x + 60,
            y2: y + 60
        });
    }
}
let spellMenuOpen = false;

// otw√≥rz menu pod E
document.addEventListener("keydown", e => {
    if (e.key === "e" || e.key === "E") {
        spellMenuOpen = !spellMenuOpen;

        if (spellMenuOpen) {
            updateMenuImages();
            document.getElementById("spellMenu").style.display = "block";
        } else {
            document.getElementById("spellMenu").style.display = "none";
        }
    }
});


// zamykanie
function closeSpellMenu() {
    spellMenuOpen = false;
    document.getElementById("spellMenu").style.display = "none";
}

// wyb√≥r slotu
document.querySelectorAll(".slotOption").forEach(opt => {
    opt.addEventListener("click", () => {
        const slot = opt.dataset.slot;
        document.querySelector("#slot" + slot + " img").src = "czar1.png";
        closeSpellMenu();
    });
});
function updateMenuImages() {
    ["menuSpell1","menuSpell2","menuSpell3"].forEach((id,i)=>{
        const img = document.getElementById(id);
        const spell = spellsInSlots[i+1];

        if (spell) {
            img.src = spell;
            img.style.opacity = "1";
        } else {
            img.src = "";       // NIC
            img.style.opacity = "0.3";  // wyglƒÖda jak puste miejsce
        }
    });
}

document.querySelectorAll(".menuSpell").forEach((img, index) => {
    img.addEventListener("click", () => {
        if (!spellsInSlots[index+1]) return;  // NIE KLIKASZ pustych

        pickedSpell = index + 1;

        // opcjonalnie pod≈õwietlenie
        document.querySelectorAll(".menuSpell").forEach(m => m.style.borderColor="#555");
        img.style.borderColor = "yellow";
    });
});

document.querySelectorAll(".menuSlot").forEach(btn => {
    btn.addEventListener("click", () => {
        if (!pickedSpell) return;

        const target = btn.dataset.slot;

        // zamiana
        let temp = spellsInSlots[target];
        spellsInSlots[target] = spellsInSlots[pickedSpell];
        spellsInSlots[pickedSpell] = temp;

        // aktualizacja HUD
        document.querySelector("#slot" + target + " img").src = spellsInSlots[target];
        document.querySelector("#slot" + pickedSpell + " img").src = spellsInSlots[pickedSpell];

        pickedSpell = null;
        updateMenuImages();
    });
});

function fireSpellTowardMouse(slot) {
// --- NOWY CZAR LECZENIA ---


// --- NOWY OGNIWY CZAR ---
if (spellsInSlots[slot] === "czar2.png") {
    fireFireSpell(slot);
    return;
}

// --- NOWY CZAR: Lustrzany Portal ---
if (spellsInSlots[slot] === "czar3.png") {
    createMirrorPortal();
    return;
}

    const gx = playerX + 20;
    const gy = playerY + 20;

    const mx = mouseX + camX;
    const my = mouseY + camY;

    const dx = mx - gx;
    const dy = my - gy;

    const len = Math.hypot(dx, dy);
    const vx = (dx / len) * 8;
    const vy = (dy / len) * 8;

    const ball = document.createElement("img");
    ball.src = "pocisk1.png";
    ball.style.position = "absolute";

    const w = 120;
    const h = 60;

    ball.style.width = w + "px";
    ball.style.height = h + "px";

    ball.style.left = (gx - w/2) + "px";
    ball.style.top  = (gy - h/2) + "px";

    ball.style.transform = `rotate(${Math.atan2(vy, vx)}rad)`;
    ball.style.zIndex = 20;
    world.appendChild(ball);

    // ‚≠ê NAJWA≈ªNIEJSZE: zapis slotu
  projectiles.push({
    el: ball,
    x: gx - w/2,
    y: gy - h/2,
    dx: vx,
    dy: vy,
    slot: slot,
    spellType: "czar1"
});

}

function chooseBossRoom() {
    let bx, by;

    while (true) {
        bx = Math.floor(Math.random() * DUNGEON_W);
        by = Math.floor(Math.random() * DUNGEON_H);

        // nie mo≈ºe byƒá to pok√≥j startowy (1,1)
        if (bx === 1 && by === 1) continue;

        // pok√≥j z bossem musi byƒá kwadratowy (template index 0)
        if (dungeon[by][bx].template !== 0) continue;

        break;
    }

    dungeon[by][bx].isBossRoom = true;
}
function spawnBoss() {
    const tile = currentWalkable[Math.floor(Math.random() * currentWalkable.length)];
    const x = tile.x1 + TILE_SIZE/2 - 80;
    const y = tile.y1 + TILE_SIZE/2 - 80;
// ‚≠ê Mirror Boss ‚Äì 20% szansy, tylko w lustrzanym ≈õwiecie
if (inMirrorWorld && Math.random() < 0.20) {
    spawnMirrorBoss(x, y);
    return;
}
if (worldType === "darkforest") {
    // 50% szans na nowego bossa
    if (Math.random() < 0.5) {
        spawnForestChargerBoss(x, y);
    } else {
        spawnSlimeKingBoss(x, y);
    }
    return;
}


    // ‚≠ê NOWO≈öƒÜ ‚Äì szansa na nowego bossa
    if (Math.random() < 0.33) {   // 33% szansy
        spawnPlantBoss(x, y);
        return;
    }

   if (worldType === "desert") {
    // 50% na skorpiona, 50% na Antlion Kinga
    if (Math.random() < 0.5) {
        spawnDesertBoss(x, y);
    } else {
        spawnAntlionKing(x, y);
    }
    return;
}


    // klasyczne losowanie lasowe
    const pick = Math.random() < 0.5 ? "old" : "butterfly";
    if (pick === "old") spawnOldBoss(x, y);
    else spawnButterflyBoss(x, y);
}



function updateBossLogic(boss, delta) {
if (boss.bossType === "desert") {
    return updateDesertBoss(boss, delta);
}
if (boss.bossType === "mirror") {
    return updateMirrorBoss(boss, delta);
}
if (boss.bossType === "forestCharger") {
    return updateForestChargerBoss(boss, delta);
}

if (boss.bossType === "slimeKing") {
    return updateSlimeKingBoss(boss, delta);
}

if (boss.bossType === "plant") {
    return updatePlantBoss(boss, delta);
}

    // üëπ STARY BOSS ‚Äì SZAR≈ªA
    if (boss.bossType === "old") {

        return updateOldBoss(boss, delta);
    }
if (boss.bossType === "antlionKing") {
    return updateAntlionKing(boss, delta);
}

    // ü¶ã NOWY BOSS ‚Äì MOTYLEK
   if (boss.bossType === "butterfly") {

        return updateButterflyBoss(boss, delta);
    }
}

function enemyFireProjectile(enemy) {
    const gx = playerX + 20;
    const gy = playerY + 20;

    const ex = enemy.x + 20;
    const ey = enemy.y + 20;

    const dx = gx - ex;
    const dy = gy - ey;
    const len = Math.hypot(dx, dy);

const vx = (dx / len) * 4 * enemyProjectileSpeedMultiplier;
const vy = (dy / len) * 4 * enemyProjectileSpeedMultiplier;


    const ball = document.createElement("img");
    ball.src = "pocisk2.png";  // zielony pocisk
    ball.style.position = "absolute";
    ball.style.width = "40px";
    ball.style.height = "40px";
    ball.style.left = (ex - 20) + "px";
    ball.style.top  = (ey - 20) + "px";
    ball.style.zIndex = 20;

    world.appendChild(ball);

    enemyProjectiles.push({
        el: ball,
        x: ex - 20,
        y: ey - 20,
        dx: vx,
        dy: vy,
        damage: enemy.type.attackDamage
    });
}
function updateEnemyProjectiles() {
    for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
        const p = enemyProjectiles[i];

        p.x += p.dx;
        p.y += p.dy;

        p.el.style.left = p.x + "px";
        p.el.style.top  = p.y + "px";

        // Kolizja z graczem
        if (
            p.x < playerX + 40 &&
            p.x + 40 > playerX &&
            p.y < playerY + 40 &&
            p.y + 40 > playerY
        ) {
            playerHP -= p.damage * (1 - damageReduction);

            updateHP();

            p.el.remove();
            enemyProjectiles.splice(i, 1);
            continue;
        }

        // Usuniƒôcie gdy za daleko
        if (p.x < -5000 || p.x > 5000 || p.y < -5000 || p.y > 5000) {
            p.el.remove();
            enemyProjectiles.splice(i, 1);
        }
    }
}
function updateGold() {
    const goldText = document.querySelector("#goldHUD #goldAmount");
    if (goldText) goldText.textContent = gold;
}

function spawnTrader() {
    const room = dungeon[currentRoomY][currentRoomX];

    // ‚õî blokujemy TYLKO zwyk≈Çych handlarzy w walce
    if (room.isFightRoom) {
        // ALE pustynny mo≈ºe siƒô pojawiƒá
        if (
            desertTraderSpawned &&
            desertTraderRoom &&
            desertTraderRoom.x === currentRoomX &&
            desertTraderRoom.y === currentRoomY
        ) {
            spawnDesertTraderHere();
        }
        return;
    }


    // odtwarzanie
    if (
        normalTraderSpawned &&
        normalTraderRoom?.x === currentRoomX &&
        normalTraderRoom?.y === currentRoomY
    ) {
        spawnTraderHere("normal");
        return;
    }

    if (
        puddingTraderSpawned &&
        puddingTraderRoom?.x === currentRoomX &&
        puddingTraderRoom?.y === currentRoomY
    ) {
        spawnTraderHere("pudding");
        return;
    }

    // zwyk≈Çy handlarz ‚Äì je≈õli MA siƒô pojawiƒá
    if (normalTraderWillSpawn && !normalTraderSpawned) {
        normalTraderSpawned = true;
        normalTraderRoom = { x: currentRoomX, y: currentRoomY };
        spawnTraderHere("normal");
        return;
    }

    // pudding ‚Äì je≈õli MA siƒô pojawiƒá
    if (puddingTraderWillSpawn && !puddingTraderSpawned) {
        puddingTraderSpawned = true;
        puddingTraderRoom = { x: currentRoomX, y: currentRoomY };
        spawnTraderHere("pudding");
        return;
    }
// ü¶Ç HANDLARZ PUSTYNNY
if (
    worldType === "desert" &&
    desertTraderWillSpawn &&
    !desertTraderSpawned
) {
    desertTraderSpawned = true;
    desertTraderRoom = { x: currentRoomX, y: currentRoomY };
    spawnDesertTraderHere();
}
else if (
    worldType === "desert" &&
    desertTraderSpawned &&
    desertTraderRoom &&
    desertTraderRoom.x === currentRoomX &&
    desertTraderRoom.y === currentRoomY
) {
    spawnDesertTraderHere();
}


}



document.addEventListener("keydown", e => {
    if (e.key === " ") {
        // je≈õli sklep otwarty ‚Üí zamknij
        if (shopOpen) {
            closeShop();
            return;
        }

        if (!currentTrader) return;

        const dist = Math.hypot(
            (playerX - currentTrader.x),
            (playerY - currentTrader.y)
        );

        if (dist < 120) {
            openShop();
        }
    }
});
function openShop() {
    shopOpen = true;

    if (!currentTrader) return;

    if (currentTrader.type === "pudding") {
        document.getElementById("puddingShop").style.display = "block";
    }
    else if (currentTrader.type === "desert") {
        document.getElementById("desertShop").style.display = "block";
    }
    else {
        document.getElementById("shopMenu").style.display = "block";
    }
}




function closeShop() {
    shopOpen = false;
    document.getElementById("shopMenu").style.display = "none";
    document.getElementById("puddingShop").style.display = "none";
    document.getElementById("desertShop").style.display = "none";
    document.getElementById("shopSlots").innerHTML = "";
}


document.getElementById("buySpell1").onclick = () => {
    if (!shopOpen) return;

    if (gold < 30) {
        alert("Masz za ma≈Ço z≈Çota!");
        return;
    }

    const cont = document.getElementById("shopSlots");
    cont.innerHTML = "<h3>Wybierz slot na czar:</h3>";

    // ‚≠ê Mo≈ºna nadpisywaƒá sloty 1‚Äì3
    for (let s = 1; s <= 3; s++) {
        const btn = document.createElement("div");
        btn.className = "shopItem";
        btn.textContent = `Slot ${s} (teraz: ${spellsInSlots[s] || "pusty"})`;

        btn.onclick = () => {
            gold -= 30;
            updateGold();

            spellsInSlots[s] = "czar1.png";
            document.querySelector(`#slot${s} img`).src = "czar1.png";

            closeShop();
        };

        cont.appendChild(btn);
    }
};




document.getElementById("buyCat").onclick = () => {
    if (!shopOpen) return;

    if (gold < 10) {
        alert("Za ma≈Ço z≈Çota!");
        return;
    }

    gold -= 10;
    updateGold();

    // dodajemy item do listy
    magicItems.push("catfriend.png");
    updateItemHUD();

    spawnCatFollower();

    closeShop();
};

let catFollower = null;

function spawnCatFollower() {
    if (catFollower && catFollower.el) catFollower.el.remove();

    const cat = document.createElement("img");
    cat.src = "cat.png";
    cat.style.position = "absolute";
    cat.style.width = "40px";
    cat.style.height = "40px";
    cat.style.zIndex = 9;

    world.appendChild(cat);

    catFollower = {
        el: cat,
        x: playerX - 50,
        y: playerY - 50,
        attackCooldown: 0
    };
}

function updateCatFollower(delta) {
    if (!catFollower) return;

    let targetX, targetY;

    // üü¶ JE≈öLI SƒÑ WROGOWIE ‚Äî kot szuka najbli≈ºszego
    if (currentEnemies.length > 0) {
        let nearest = null;
        let bestDist = Infinity;

        for (const e of currentEnemies) {
            const dx = e.x - catFollower.x;
            const dy = e.y - catFollower.y;
            const dist = dx*dx + dy*dy;
            if (dist < bestDist) {
                bestDist = dist;
                nearest = e;
            }
        }

        targetX = nearest.x;
        targetY = nearest.y;
    }

    // üüß JE≈öLI NIE MA WROG√ìW ‚Äî kot idzie za graczem
    else {
        targetX = playerX;
        targetY = playerY;
    }

    // RUCH W KIERUNKU CELU
    const dx = targetX - catFollower.x;
    const dy = targetY - catFollower.y;
    const dist = Math.hypot(dx, dy);

    if (dist > 20) {
        catFollower.x += dx / dist * 2.5;  // 2.5 = wolniejszy i ≈Çadniejszy ruch
        catFollower.y += dy / dist * 2.5;
    }

    catFollower.el.style.left = catFollower.x + "px";
    catFollower.el.style.top  = catFollower.y + "px";

    // ZARZƒÑDZANIE ATAKAMI
    catFollower.attackCooldown -= delta;

    if (currentEnemies.length > 0 && catFollower.attackCooldown <= 0) {
        attackWithCat();
        catFollower.attackCooldown = 1300; // üê± wolniejszy atak: 1.3 sekundy
    }
}

function attackWithCat() {
    if (!currentEnemies.length) return;

    for (const e of currentEnemies) {

        // hitbox dla bossa wiƒôkszy
        const hitRange = e.isBoss ? 160 : 40;

        const dx = e.x - catFollower.x;
        const dy = e.y - catFollower.y;
        const dist = Math.hypot(dx, dy);

        const attackDist = e.isBoss ? 180 : 110;

        if (dist < attackDist) {

            // niebieski warn
            const warn = document.createElement("div");
            warn.style.position = "absolute";
            warn.style.width = "120px";
            warn.style.height = "120px";
            warn.style.borderRadius = "50%";
            warn.style.background = "rgba(0,150,255,0.25)";
            warn.style.left = (e.x + 20 - 60) + "px";
            warn.style.top  = (e.y + 20 - 60) + "px";
            warn.style.zIndex = 2;
            world.appendChild(warn);
            setTimeout(() => warn.remove(), 200);

            // obra≈ºenia
            e.hp -= 1;

            // aktualizacja paska HP
            if (e.isBoss) {
                const percentBoss = e.hp / e.maxHP;
                document.getElementById("bossBarFill").style.width = (percentBoss * 100) + "%";
            } else if (e.hpFill) {
                const percent = e.hp / e.type.maxHP;
                e.hpFill.style.width = (percent * 100) + "%";
            }

            // efekt trafienia
            e.el.style.filter = "brightness(2)";
            setTimeout(() => e.el.style.filter = "brightness(1)", 100);

            // odpadniecie
         if (e.hp <= 0) {

    gold += 10;
    updateGold();

    // ‚≠ê JE≈öLI TO BOSS ‚Äî u≈ºyj PE≈ÅNEJ logiki bossa
    if (e.isBoss) {
        destroyBoss(e);

        dungeon[currentRoomY][currentRoomX].isBossRoomCleared = true;
        dungeon[currentRoomY][currentRoomX].fightCleared = true;

        // nagrody + portal
        showBossRewards(() => {
            spawnPortal(e.x + 80, e.y + 80);
        });
    }

    e.el.remove();
    if (e.warn) e.warn.remove();
    if (e.hpBar) e.hpBar.remove();

    currentEnemies.splice(currentEnemies.indexOf(e), 1);
}


            return;
        }
    }
}
function spawnPortal(x, y) {
    const portal = document.createElement("div");
    portal.className = "portal";
    portal.style.left = (x - 60) + "px"; 
    portal.style.top  = (y - 60) + "px";

    world.appendChild(portal);

 portal.addEventListener("click", () => {
    if (isTransitioning) return;

    isTransitioning = true;

    startNextLevel();

    // üî• WYMUSZAMY odblokowanie pƒôtli
    setTimeout(() => {
        isTransitioning = false;
    }, 50);
});


}
function startNextLevel() {
// üî• HARD RESET WSZYSTKICH WROG√ìW I TIMER√ìW
currentEnemies.forEach(e => {

    e.dead = true;

    if (e.jumpTimeout) clearTimeout(e.jumpTimeout);
    if (e.vortexInterval) clearInterval(e.vortexInterval);

    if (e.warningEl) e.warningEl.remove();
    if (e.field) e.field.remove();
    if (e.hpBar) e.hpBar.remove();
    if (e.el) e.el.remove();
});

currentEnemies = [];


enemyProjectiles.forEach(p => p.el && p.el.remove());
enemyProjectiles = [];
projectiles.forEach(p => p.el && p.el.remove());
projectiles = [];

    document.querySelectorAll(".portal").forEach(p => p.remove());

    worldLevel++;

    if (worldLevel >= 5) {
    worldType = "darkforest";
} else if (worldLevel >= 3) {
    worldType = "desert";
} else {
    worldType = "forest";
}


    buildDungeon();
    chooseBossRoom();
rollTradersForFloor();
    currentRoomX = 1;
    currentRoomY = 1;
isTransitioning = false;
    enterRoom(currentRoomX, currentRoomY);

    
}



function findEdgeFloor(tmpl, edge) {
    let tiles = [];

    if (edge === "top") {
        for (let x = 0; x < ROOM_COLS; x++)
            if (tmpl[0][x] === 1) tiles.push(x);
    }

    if (edge === "bottom") {
        for (let x = 0; x < ROOM_COLS; x++)
            if (tmpl[ROOM_ROWS-1][x] === 1) tiles.push(x);
    }

    if (edge === "left") {
        for (let y = 0; y < ROOM_ROWS; y++)
            if (tmpl[y][0] === 1) tiles.push(y);
    }

    if (edge === "right") {
        for (let y = 0; y < ROOM_ROWS; y++)
            if (tmpl[y][ROOM_COLS-1] === 1) tiles.push(y);
    }

    if (tiles.length === 0) return null;

    return tiles[Math.floor(Math.random() * tiles.length)];
}
function spawnOldBoss(x, y) {
    const boss = document.createElement("div");
    boss.className = "enemy boss";
    boss.style.width = "160px";
    boss.style.height = "160px";
    boss.style.background = "url('boss1.png') center/cover no-repeat";
    boss.style.left = x + "px";
    boss.style.top  = y + "px";

    world.appendChild(boss);

    currentEnemies.push({
        el: boss,
        x: x,
        y: y,
        hp: 200,
        maxHP: 200,
        isBoss: true,
        bossType: "old",

        chargeCooldown: 0,
        isCharging: false,
        hasHitThisCharge: false
    });
}


function spawnButterflyBoss(x, y) {
    const boss = document.createElement("div");
    boss.className = "enemy boss";
    boss.style.width = "160px";
    boss.style.height = "160px";
    boss.style.background = "url('boss2.png') center/contain no-repeat";
    boss.style.left = x + "px";
    boss.style.top  = y + "px";

    world.appendChild(boss);

    currentEnemies.push({
        el: boss,
        x: x,
        y: y,
        hp: 200,
        maxHP: 200,
        isBoss: true,
        bossType: "butterfly",

        attackTimer: 0,        // ‚≠ê BRAKOWA≈ÅO!
        attackCooldown: 1500,  // ‚≠ê BRAKOWA≈ÅO!

        chargeCooldown: 0,
        isCharging: false,
        hasHitThisCharge: false
    });
}

function updateOldBoss(boss, delta) {
    const gx = playerX;
    const gy = playerY;
    const dx = gx - boss.x;
    const dy = gy - boss.y;
    const dist = Math.hypot(dx, dy);

    boss.chargeCooldown -= delta;

    if (!boss.isCharging) {
        boss.x += dx / dist * 1.5;
        boss.y += dy / dist * 1.5;
        boss.el.style.left = boss.x + "px";
        boss.el.style.top  = boss.y + "px";

        if (boss.chargeCooldown <= 0) {
            boss.isCharging = true;
            boss.hasHitThisCharge = false;

            const len = dist;
            boss.chargeDX = dx / len * 6;
            boss.chargeDY = dy / len * 6;

            boss.chargeTime = 700;
            boss.el.style.filter = "brightness(2)";
        }
        return;
    }

    boss.chargeTime -= delta;
    boss.x += boss.chargeDX;
    boss.y += boss.chargeDY;
    boss.el.style.left = boss.x + "px";
    boss.el.style.top  = boss.y + "px";

    if (!boss.hasHitThisCharge) {
        if (rectsOverlap(boss.x, boss.y, 160, 160, playerX, playerY, 40, 40)) {
            playerHP -= 15 * (1 - damageReduction);

            updateHP();
            boss.hasHitThisCharge = true;
        }
    }

    if (boss.chargeTime <= 0) {
        boss.isCharging = false;
        boss.chargeCooldown = 2000;
        boss.el.style.filter = "brightness(1)";
    }
}
function updateButterflyBoss(boss, delta) {
    const gx = playerX;
    const gy = playerY;
    const dx = gx - boss.x;
    const dy = gy - boss.y;
    const dist = Math.hypot(dx, dy);

    // ruch wolny
    boss.x += dx / dist * 1.2;
    boss.y += dy / dist * 1.2;
    boss.el.style.left = boss.x + "px";
    boss.el.style.top  = boss.y + "px";

    boss.attackTimer += delta;

    if (boss.attackTimer > boss.attackCooldown) {
        boss.attackTimer = 0;

        // üé≤ 50/50 kt√≥ry atak
        if (Math.random() < 0.5) {
            butterflyShoot(boss);
        } else {
            butterflyPixelAttack();
        }
    }
}
function butterflyShoot(boss) {
    const gx = playerX + 20;
    const gy = playerY + 20;
    const ex = boss.x + 80;
    const ey = boss.y + 80;

    const dx = gx - ex;
    const dy = gy - ey;
    const len = Math.hypot(dx, dy);

    const vx = dx / len * 6;
    const vy = dy / len * 6;

    const ball = document.createElement("img");
    ball.src = "pocisk2.png";
    ball.style.position = "absolute";
    ball.style.width = "40px";
    ball.style.height = "40px";
    ball.style.left = (ex - 20) + "px";
    ball.style.top  = (ey - 20) + "px";
    ball.style.zIndex = 20;

    world.appendChild(ball);

    enemyProjectiles.push({
        el: ball,
        x: ex - 20,
        y: ey - 20,
        dx: vx,
        dy: vy,
        damage: 8
    });
}
function butterflyPixelAttack() {
    // powiƒôkszamy grƒô
    gameContainer.style.transform = "scale(3)";
    gameContainer.style.transformOrigin = "center center";

    // wymuszenie pixel-artowego renderowania
    gameContainer.style.imageRendering = "pixelated";

   setTimeout(() => {
    if (!gameContainer) return;
    gameContainer.style.transform = "scale(1)";
    gameContainer.style.imageRendering = "auto";
}, 450);
// 0.45 sekundy
}
document.getElementById("buyMirrorSpell").onclick = () => {
    if (!shopOpen) return;

    if (gold < 50) {
        alert("Za ma≈Ço z≈Çota!");
        return;
    }

    const cont = document.getElementById("shopSlots");
    cont.innerHTML = "<h3>Wybierz slot na Lustrzany Portal:</h3>";

    // ‚≠ê Mo≈ºna nadpisywaƒá sloty 1‚Äì3
    for (let s = 1; s <= 3; s++) {
        const btn = document.createElement("div");
        btn.className = "shopItem";
        btn.textContent = `Slot ${s} (teraz: ${spellsInSlots[s] || "pusty"})`;

        btn.onclick = () => {
            gold -= 50;
            updateGold();

            spellsInSlots[s] = "czar3.png";
            document.querySelector(`#slot${s} img`).src = "czar3.png";

            closeShop();
        };

        cont.appendChild(btn);
    }
};

let mirrorMode = false;
let mirrorTimer = 0;

/* -------------------------------------------------
    FUNKCJA: tworzy niebieski portal pod graczem,
    kt√≥ry przenosi do lustrzanej wersji mapy
--------------------------------------------------*/
function createMirrorPortal() {
    const px = playerX + 20;
    const py = playerY + 20;

    const portal = document.createElement("div");
    portal.className = "portal";
    portal.style.background = "radial-gradient(circle, #4ab6ff, #004a88)";
    portal.style.boxShadow = "0 0 25px #4ab6ff";
    portal.style.left = (px - 60) + "px";
    portal.style.top  = (py - 60) + "px";

    world.appendChild(portal);

    portal.addEventListener("click", () => {
        enterMirrorWorld();
        portal.remove();
    });

    // portal znika po 5 sek
    setTimeout(() => {
        portal.remove();
    }, 5000);
}

/* -------------------------------------------------
    WEJ≈öCIE DO LUSTRA
--------------------------------------------------*/
function enterMirrorWorld() {
    if (inMirrorWorld) return;

    // 1. Utw√≥rz lustrzany ≈õwiat je≈õli jeszcze go nie ma
    if (!mirrorDungeon) {
        mirrorDungeon = cloneDungeon(dungeon);
    }

    // 2. Prze≈ÇƒÖcz na ≈õwiat lustra
    inMirrorWorld = true;

    // 3. Zmie≈Ñ wyglƒÖd ≈õwiata
    world.style.filter = "invert(1) hue-rotate(180deg)";
    world.style.transform = "scaleX(-1)";

    // 4. Podmie≈Ñ aktualny dungeon
    previousDungeon = dungeon;
    dungeon = mirrorDungeon;

    // 5. Wejd≈∫ do tego samego pokoju, ale w lustrzanym ≈õwiecie
    enterRoom(currentRoomX, currentRoomY);

    // 6. Odbicie sterowania
    mirrorControls = true;
}


/* -------------------------------------------------
    WYJ≈öCIE Z LUSTRA
--------------------------------------------------*/
function exitMirrorWorld() {
    mirrorMode = false;
    mirrorControls = false;

    world.style.filter = "none";
    world.style.transform = world.style.transform.replace("scaleX(-1)", "");
}
function cloneDungeon(original) {
    return original.map(row =>
        row.map(room => ({
            template: room.template,
            hasGoal: room.hasGoal,
            goalTile: room.goalTile,
            isFightRoom: room.isFightRoom,
            fightCleared: room.fightCleared, // zachowujemy
            isBossRoom: room.isBossRoom,
            bossSpawned: false
        }))
    );
}
function spawnReturnPortal(x, y) {
    const portal = document.createElement("div");
    portal.className = "portal";
    portal.style.left = (x - 60) + "px";
    portal.style.top  = (y - 60) + "px";

    world.appendChild(portal);

    portal.addEventListener("click", () => {
        returnFromMirrorWorld();
        portal.remove();
    });
}
function returnFromMirrorWorld() {
    if (!inMirrorWorld) return;

    inMirrorWorld = false;

    // przywr√≥ƒá normalnƒÖ mapƒô
    dungeon = previousDungeon;

    mirrorControls = false;

    // reset filtr√≥w
    world.style.filter = "none";
    world.style.transform = "none";

    // üî• TELEPORT DO CENTRUM ZWYK≈ÅEJ MAPY
    currentRoomX = 1;
    currentRoomY = 1;
    enterRoom(1, 1, null);
}

window.addEventListener("contextmenu", e => e.preventDefault());
function showBossRewards(onFinish) {
    const menu = document.getElementById("rewardMenu");

    const r1 = document.getElementById("reward1");
    const r2 = document.getElementById("reward2");
    const r3 = document.getElementById("reward3");
    const r4 = document.getElementById("reward4");

    const rewards = [
        {
            text: "üî• +5 obra≈ºe≈Ñ dla czar√≥w ofensywnych",
            apply: () => bonusDamage += 5
        },
        {
            text: "‚è±Ô∏è -2 sekundy cooldownu czaru 1",
            apply: () => bonusCooldown += 2
        },
        {
            text: "üí∞ +70 z≈Çota",
            apply: () => { gold += 70; updateGold(); }
        },
        {
            text: "‚ù§Ô∏è +20 HP",
            apply: () => {
                playerHP = Math.min(playerHP + 20, 100);
                updateHP();
            }
        }
    ];

    // losujemy 2 r√≥≈ºne klasyczne nagrody
    const a = rewards.splice(Math.floor(Math.random() * rewards.length), 1)[0];
    const b = rewards.splice(Math.floor(Math.random() * rewards.length), 1)[0];

    r1.textContent = a.text;
    r2.textContent = b.text;
    r3.textContent = "‚ú® Losowy czar";
    r4.textContent = "üéÅ Losowy item";

    menu.style.display = "block";

    r1.onclick = () => { a.apply(); close(); };
    r2.onclick = () => { b.apply(); close(); };
    r3.onclick = () => { giveRandomSpellReward(); };

    r4.onclick = () => { giveRandomItemReward(); close(); };

    function close() {
        menu.style.display = "none";
        onFinish();
    }
}

function spawnCactus() {
    if (!currentWalkable || currentWalkable.length === 0) return;

    currentTrees = [];

    const cactusCount = Math.floor(Math.random() * 3) + 1;

    for (let i = 0; i < cactusCount; i++) {
        const tile = currentWalkable[Math.floor(Math.random() * currentWalkable.length)];

        const x = tile.x1 + TILE_SIZE/2 - 80; 
        const y = tile.y1 + TILE_SIZE/2 - 80;

       const cactus = document.createElement("div");
cactus.className = "cactus";

        cactus.style.position = "absolute";
        cactus.style.width = "160px";
        cactus.style.height = "160px";
        cactus.style.background = "url('cactus.png') center/contain no-repeat";
        cactus.style.left = x + "px";
        cactus.style.top  = y + "px";
        cactus.style.zIndex = 4;

        world.appendChild(cactus);

        currentTrees.push({
            el: cactus,
            x1: x,
            y1: y,
            x2: x + 160,
            y2: y + 160
        });
    }
}
function spawnSandRocks() {
    currentFlowers = [];

    const rockCount = Math.floor(Math.random() * 3) + 1;

    for (let i = 0; i < rockCount; i++) {
        const tile = currentWalkable[Math.floor(Math.random() * currentWalkable.length)];

        const x = tile.x1 + TILE_SIZE/2 - 30;
        const y = tile.y1 + TILE_SIZE/2 - 30;

        const rock = document.createElement("div");
rock.className = "rock";

        rock.style.position = "absolute";
        rock.style.width = "60px";
        rock.style.height = "60px";
        rock.style.background = "url('rock.png') center/contain no-repeat";
        rock.style.left = x + "px";
        rock.style.top  = y + "px";
        rock.style.zIndex = 3;

        world.appendChild(rock);

        currentFlowers.push({
            el: rock,
            x1: x,
            y1: y,
            x2: x + 60,
            y2: y + 60
        });
    }
}
function spawnDesertBoss(x, y) {
    const boss = document.createElement("div");
    boss.className = "enemy boss";
    boss.style.width = "160px";
    boss.style.height = "160px";
    boss.style.background = "url('boss3.png') center/cover no-repeat";
    boss.style.left = x + "px";
    boss.style.top  = y + "px";

    world.appendChild(boss);

    currentEnemies.push({
        el: boss,
        x: x,
        y: y,
        hp: 160,
        maxHP: 160,
        isBoss: true,
        bossType: "desert",

        phase: 0,              // 0 = idle, 1 = charge1, 2 = charge2
        chargeDX: 0,
        chargeDY: 0,
        chargeTime: 0,
        hasHit: false,

        attackCooldown: 2000,  // przerwa miƒôdzy atakami
        attackTimer: 0
    });
}
function updateDesertBoss(boss, delta) {
    const gx = playerX + 20;
    const gy = playerY + 20;
    const bx = boss.x + 80;
    const by = boss.y + 80;

    const dx = gx - bx;
    const dy = gy - by;
    const dist = Math.hypot(dx, dy);

    boss.attackTimer += delta;

    // ---------- ETAP: WYB√ìR ATAKU ----------
    if (boss.phase === 0 && boss.attackTimer > boss.attackCooldown) {
        boss.attackTimer = 0;

        if (Math.random() < 0.5) {
            startDesertCharge(boss, dx, dy);
        } else {
            startDesertShoot(boss, dx, dy);
        }
    }

    // ---------- ETAP: SZAR≈ªA ----------
    if (boss.phase === 1 || boss.phase === 2) {
        boss.chargeTime -= delta;
        boss.x += boss.chargeDX;
        boss.y += boss.chargeDY;

        boss.el.style.left = boss.x + "px";
        boss.el.style.top  = boss.y + "px";

        // kolizja tylko RAZ
        if (!boss.hasHit) {
            if (rectsOverlap(boss.x, boss.y, 160, 160, playerX, playerY, 40, 40)) {
                playerHP -= 12 * (1 - damageReduction);

                updateHP();
                boss.hasHit = true;
            }
        }

        if (boss.chargeTime <= 0) {
            if (boss.phase === 1) {
                // przej≈õcie do drugiej szar≈ºy
                boss.phase = 2;
                boss.hasHit = false;
                boss.chargeTime = 250;
            } else {
                // koniec szar≈º
                boss.phase = 0;
            }
        }
    }
}
function startDesertCharge(boss, dx, dy) {
    const len = Math.hypot(dx, dy);

    boss.chargeDX = (dx / len) * 11;   // szybka, ale kr√≥tka szar≈ºa
    boss.chargeDY = (dy / len) * 11;

    boss.phase = 1;        // pierwsza szar≈ºa
    boss.chargeTime = 250; // bardzo kr√≥tka
    boss.hasHit = false;

    boss.el.style.filter = "brightness(1.8)";
    setTimeout(() => boss.el.style.filter = "brightness(1)", 250);
}
function startDesertShoot(boss, dx, dy) {
    boss.phase = 0;

    shootDesertBullet(boss, dx, dy);

    setTimeout(() => {
        // üîí JE≈öLI BOSS JU≈ª ODPAD≈Å ‚Üí NIC NIE R√ìB
        if (!boss.el || !boss.el.parentNode || boss.hp <= 0) return;
        shootDesertBullet(boss, dx, dy);
    }, 300);
}

function shootDesertBullet(boss, dx, dy) {
    const len = Math.hypot(dx, dy);
    const vx = (dx / len) * 6;
    const vy = (dy / len) * 6;

    const ex = boss.x + 80;
    const ey = boss.y + 40; // ogon skorpiona

    const ball = document.createElement("img");
    ball.src = "pocisk2.png";
    ball.style.position = "absolute";
    ball.style.width = "60px";
    ball.style.height = "60px";
    ball.style.left = (ex - 30) + "px";
    ball.style.top  = (ey - 30) + "px";
    ball.style.zIndex = 20;
    world.appendChild(ball);

    enemyProjectiles.push({
        el: ball,
        x: ex - 30,
        y: ey - 30,
        dx: vx,
        dy: vy,
        damage: 10
    });
}
function spawnPlantBoss(x, y) {
    const boss = document.createElement("div");
    boss.className = "enemy boss";
    boss.style.width = "160px";
    boss.style.height = "160px";
    boss.style.background = "url('boss4.png') center/contain no-repeat";
    boss.style.left = x + "px";
    boss.style.top  = y + "px";

    world.appendChild(boss);

    currentEnemies.push({
        el: boss,
        x: x,
        y: y,
        hp: 140,
        maxHP: 140,
        isBoss: true,
        bossType: "plant",

        attackCooldown: 1800,
        attackTimer: 0
    });
}
function updatePlantBoss(boss, delta) {
    boss.attackTimer += delta;

    if (boss.attackTimer < boss.attackCooldown) return;
    boss.attackTimer = 0;

    // 50/50 kt√≥ry atak
    if (Math.random() < 0.5) {
        plantTripleShot(boss);
    } else {
        plantDoubleRandomShot(boss);
    }
}
function plantTripleShot(boss) {
    const bx = boss.x + 80;
    const by = boss.y + 80;

    const angles = [-0.4, 0, 0.4]; // 3 kierunki

    angles.forEach(a => {
        const dx = (playerX + 20) - bx;
        const dy = (playerY + 20) - by;

        const len = Math.hypot(dx, dy);
        let vx = (dx / len) * 6;
        let vy = (dy / len) * 6;

        // skrƒôcanie pod kƒÖtem
        const cos = Math.cos(a);
        const sin = Math.sin(a);

        const rx = vx * cos - vy * sin;
        const ry = vx * sin + vy * cos;

        plantShootBullet(bx, by, rx, ry);
    });
}
function plantDoubleRandomShot(boss) {
    const bx = boss.x + 80;
    const by = boss.y + 80;

    for (let i = 0; i < 2; i++) {
        const angle = Math.random() * Math.PI * 2;
        const vx = Math.cos(angle) * 5;
        const vy = Math.sin(angle) * 5;

        plantShootBullet(bx, by, vx, vy);
    }
}
function plantShootBullet(x, y, vx, vy) {
    const ball = document.createElement("img");
    ball.src = "pocisk2.png";
    ball.style.position = "absolute";
    ball.style.width = "40px";
    ball.style.height = "40px";
    ball.style.left = (x - 20) + "px";
    ball.style.top  = (y - 20) + "px";
    ball.style.zIndex = 20;

    world.appendChild(ball);

    enemyProjectiles.push({
        el: ball,
        x: x - 20,
        y: y - 20,
        dx: vx,
        dy: vy,
        damage: 8
    });
}
function spawnMirrorBoss(x, y) {
    const boss = document.createElement("div");
    boss.className = "enemy boss";
    boss.style.width = "160px";
    boss.style.height = "160px";
    boss.style.background = "url('Themirror.png') center/contain no-repeat";
    boss.style.left = x + "px";
    boss.style.top  = y + "px";
    world.appendChild(boss);

    // ‚≠ê Lustrzana kopia
    const clone = document.createElement("div");
    clone.className = "enemy boss";
    clone.style.width = "160px";
    clone.style.height = "160px";
    clone.style.background = "url('Themirror.png') center/contain no-repeat";
    clone.style.opacity = "0.85";
clone.style.filter = "none";

    clone.style.left = (x + 200) + "px";
    clone.style.top  = y + "px";
    world.appendChild(clone);

    currentEnemies.push({
        el: boss,
        x: x,
        y: y,
        hp: 180,
        maxHP: 180,
        isBoss: true,
        bossType: "mirror",
        attackCooldown: 2500,
        attackTimer: 0,
        cloneEl: clone
    });
}
function updateMirrorBoss(boss, delta) {

    // --- LOSOWY RUCH ---
    if (!boss.moveTimer) boss.moveTimer = 0;
    if (!boss.moveAngle) boss.moveAngle = Math.random() * Math.PI * 2;

    boss.moveTimer -= delta;

    // zmiana kierunku co 1.2‚Äì2.2 sekundy
    if (boss.moveTimer <= 0) {
        boss.moveTimer = 1200 + Math.random() * 1000;
        boss.moveAngle = Math.random() * Math.PI * 2;
    }

    // poruszanie (bardzo lekko losowo)
    boss.x += Math.cos(boss.moveAngle) * 1.3;
    boss.y += Math.sin(boss.moveAngle) * 1.3;
    boss.el.style.left = boss.x + "px";
    boss.el.style.top  = boss.y + "px";
// üî• BLOKADA MAPY ‚Äî boss nigdy nie wyjdzie za pok√≥j
if (boss.x < 0) boss.x = 0;
if (boss.y < 0) boss.y = 0;

if (boss.x > ROOM_W - 160) boss.x = ROOM_W - 160;  // 160 = szeroko≈õƒá bossa
if (boss.y > ROOM_H - 160) boss.y = ROOM_H - 160;

boss.el.style.left = boss.x + "px";
boss.el.style.top  = boss.y + "px";

// üî• kopia te≈º NIE mo≈ºe wyj≈õƒá za mapƒô (odbite X)
if (boss.cloneEl) {
    let cx = ROOM_W - boss.x - 160;
    let cy = boss.y;

    if (cx < 0) cx = 0;
    if (cy < 0) cy = 0;
    if (cx > ROOM_W - 160) cx = ROOM_W - 160;
    if (cy > ROOM_H - 160) cy = ROOM_H - 160;

    boss.cloneEl.style.left = cx + "px";
    boss.cloneEl.style.top  = cy + "px";
}


    // --- KOPIA PORUSZA SIƒò IDENTYCZNIE W ODBICIU ---
    if (boss.cloneEl) {
        // kopia wyglƒÖda prawie tak samo
        boss.cloneEl.style.opacity = "0.85";  
        boss.cloneEl.style.filter = "brightness(1.05)";

        boss.cloneEl.style.left = (ROOM_W - boss.x - 160) + "px";
        boss.cloneEl.style.top  = boss.y + "px";
    }

    // --- ATAKI ---
    boss.attackTimer += delta;
    if (boss.attackTimer < boss.attackCooldown) return;

    boss.attackTimer = 0;

    if (Math.random() < 0.5) {
        mirrorShootBigBullet(boss);
    } else {
        mirrorDoRingAttack(boss);
    }
}

function mirrorShootBigBullet(boss) {
    const bx = boss.x + 80;
    const by = boss.y + 80;

    const dx = (playerX + 20) - bx;
    const dy = (playerY + 20) - by;
    const len = Math.hypot(dx, dy);

    const vx = (dx / len) * 3;
    const vy = (dy / len) * 3;

    const ball = document.createElement("img");
    ball.src = "pocisk1.png";
    ball.style.position = "absolute";
    ball.style.width = "120px";
    ball.style.height = "60px";
    ball.style.left = (bx - 60) + "px";
    ball.style.top  = (by - 30) + "px";
    ball.style.zIndex = 20;
    ball.style.transform = `rotate(${Math.atan2(vy, vx)}rad)`;
    world.appendChild(ball);

    enemyProjectiles.push({
        el: ball,
        x: bx - 60,
        y: by - 30,
        dx: vx,
        dy: vy,
        damage: 15   // du≈ºy pocisk
    });
}
function mirrorDoRingAttack(boss) {
    const ring = document.createElement("div");
    ring.style.position = "absolute";
    ring.style.width = "30px";
    ring.style.height = "30px";
    ring.style.borderRadius = "50%";
    ring.style.background = "rgba(150,0,255,0.15)";
    ring.style.left = (boss.x + 65) + "px";
    ring.style.top  = (boss.y + 65) + "px";
    ring.style.zIndex = 15;
    world.appendChild(ring);

    let r = 30;
    let hitOnce = false; // üî• gracz mo≈ºe dostaƒá TYLKO RAZ od tego ataku

    const interval = setInterval(() => {
        r += 12;
        ring.style.width = r + "px";
        ring.style.height = r + "px";
        ring.style.left = (boss.x + 80 - r/2) + "px";
        ring.style.top  = (boss.y + 80 - r/2) + "px";

        if (!hitOnce) {
            if (
                playerX < boss.x + 80 + r/2 &&
                playerX + 40 > boss.x + 80 - r/2 &&
                playerY < boss.y + 80 + r/2 &&
                playerY + 40 > boss.y + 80 - r/2
            ) {
                playerHP -= 20 * (1 - damageReduction);

                updateHP();
                hitOnce = true;  // üî• tylko pierwszy raz zada obra≈ºenia
            }
        }

        if (r > 500) {
            ring.remove();
            clearInterval(interval);
        }

    }, 40);
}
document.getElementById("buyFireSpell").onclick = () => {
    if (!shopOpen) return;

    if (gold < 60) {
        alert("Masz za ma≈Ço z≈Çota!");
        return;
    }

    const cont = document.getElementById("shopSlots");
    cont.innerHTML = "<h3>Wybierz slot na ognistƒÖ kulƒô:</h3>";

    // Mo≈ºna WYBRAƒÜ TAK≈ªE ZAJƒòTY SLOT ‚Üí nadpisujemy
    for (let s = 1; s <= 3; s++) {
        const btn = document.createElement("div");
        btn.className = "shopItem";
        btn.textContent = `Slot ${s} (teraz: ${spellsInSlots[s] || "pusty"})`;

        btn.onclick = () => {
            gold -= 60;
            updateGold();

            // podmieniamy czar w tym slocie
            spellsInSlots[s] = "czar2.png";
            document.querySelector(`#slot${s} img`).src = "czar2.png";

            closeShop();
        };

        cont.appendChild(btn);
    }
};
function fireFireSpell(slot) {
    const gx = playerX + 20;
    const gy = playerY + 20;

    const mx = mouseX + camX;
    const my = mouseY + camY;

    const dx = mx - gx;
    const dy = my - gy;

    const len = Math.hypot(dx, dy);
    const vx = (dx / len) * 12; // üî• szybszy ni≈º czar 1
    const vy = (dy / len) * 12;

    const ball = document.createElement("img");
    ball.src = "pocisk3.png";  // üî• Tw√≥j nowy pocisk
    ball.style.position = "absolute";

    const w = 120;
    const h = 60;

    ball.style.width = w + "px";
    ball.style.height = h + "px";
    ball.style.left = (gx - w/2) + "px";
    ball.style.top  = (gy - h/2) + "px";
    ball.style.transform = `rotate(${Math.atan2(vy, vx)}rad)`;
    ball.style.zIndex = 20;

    world.appendChild(ball);

   projectiles.push({
    el: ball,
    x: gx - w/2,
    y: gy - h/2,
    dx: vx,
    dy: vy,
    slot: slot,
    spellType: "fireball"
});

}
document.getElementById("buyHealSpell").onclick = () => {
    if (!shopOpen) return;

    if (gold < 100) {
        alert("Masz za ma≈Ço z≈Çota!");
        return;
    }

    const cont = document.getElementById("shopSlots");
    cont.innerHTML = "<h3>Wybierz slot na czar leczenia:</h3>";

    // mo≈ºna wybraƒá r√≥wnie≈º zajƒôty slot (nadpisujemy)
    for (let s = 1; s <= 3; s++) {
        const btn = document.createElement("div");
        btn.className = "shopItem";
        btn.textContent = `Slot ${s} (teraz: ${spellsInSlots[s] || "pusty"})`;

        btn.onclick = () => {
            gold -= 100;
            updateGold();

            spellsInSlots[s] = "czar4.png";
            document.querySelector(`#slot${s} img`).src = "czar4.png";

            closeShop();
        };

        cont.appendChild(btn);
    }
};
function castHealSpell() {
    playerHP = Math.min(playerHP + 15, 100);
    updateHP();
}

function updateItemHUD() {
    const hud = document.getElementById("itemHUD");
    hud.innerHTML = "";

    magicItems.forEach(icon => {
        const img = document.createElement("img");
        img.src = icon;
        img.className = "itemIcon";
        hud.appendChild(img);
    });
}
document.getElementById("magicBar").style.display = "none";
function spawnAntlionKing(x, y) {
    const boss = document.createElement("div");
    boss.className = "enemy boss";
    boss.style.width = "160px";
    boss.style.height = "160px";
    boss.style.background = "url('boss5.png') center/contain no-repeat";
    boss.style.left = x + "px";
    boss.style.top  = y + "px";
    world.appendChild(boss);

    currentEnemies.push({
        el: boss,
        x: x,
        y: y,
        hp: 220,
        maxHP: 220,
        isBoss: true,
        bossType: "antlionKing",

        burrowed: false,        // czy pod ziemiƒÖ
        burrowTimer: 0,         // timer pod ziemiƒÖ
        attackCooldown: 2800,   // przerwa miƒôdzy atakami
        attackTimer: 0,
        hasPoppedHit: false,    // czy ju≈º trafi≈Ç wynurzeniem

        field: null // wir piaskowy
    });
}
function updateAntlionKing(boss, delta) {

    boss.attackTimer += delta;

    // ============================
    // 1) BOSS POD ZIEMIƒÑ
    // ============================
    if (boss.burrowed) {
// BOSS jest nietykalny pod ziemiƒÖ
boss.invulnerable = boss.burrowed;

        // goni gracza jako "piasek"
        const bx = boss.x + 80;
        const by = boss.y + 80;
        const gx = playerX + 20;
        const gy = playerY + 20;

        const dx = gx - bx;
        const dy = gy - by;
        const dist = Math.hypot(dx, dy);

        boss.x += (dx / dist) * 3;
        boss.y += (dy / dist) * 3;
// üîí BLOKADA POKOJU
if (boss.x < 0) boss.x = 0;
if (boss.y < 0) boss.y = 0;
if (boss.x > ROOM_W - 160) boss.x = ROOM_W - 160;
if (boss.y > ROOM_H - 160) boss.y = ROOM_H - 160;

boss.el.style.left = boss.x + "px";
boss.el.style.top  = boss.y + "px";

        boss.el.style.opacity = "0";    // niewidoczny
        boss.el.style.pointerEvents = "none";

        // czƒÖsteczki piasku
        if (!boss.particleEl) {
            const p = document.createElement("div");
            p.style.position = "absolute";
            p.style.width = "80px";
            p.style.height = "80px";
            p.style.borderRadius = "50%";
            p.style.background = "rgba(150,120,40,0.45)";
            p.style.boxShadow = "0 0 25px rgba(150,120,40,0.6)";
            p.style.zIndex = 3;
            boss.particleEl = p;
            world.appendChild(p);
        }

        boss.particleEl.style.left = (boss.x + 40) + "px";
        boss.particleEl.style.top  = (boss.y + 40) + "px";


        // Wynurzenie po czasie
        boss.burrowTimer -= delta;
        if (boss.burrowTimer <= 0) {
            boss.burrowed = false;
            boss.el.style.opacity = "1";
            boss.hasPoppedHit = false;
// üîÑ Restart kolizji po wynurzeniu ‚Äì reset pozycji na najbli≈ºszƒÖ pod≈Çogƒô
const safe = findNearestWalkableTile(boss.x + 80, boss.y + 80);
if (safe) {
    boss.x = safe.x - 80;
    boss.y = safe.y - 80;
    boss.el.style.left = boss.x + "px";
    boss.el.style.top  = boss.y + "px";
}


            if (boss.particleEl) boss.particleEl.remove();
            boss.particleEl = null;
// ‚ùó Wynurzenie ‚Äî zadaje 20 dmg TYLKO raz
if (!boss.hasPoppedHit) {
    if (rectsOverlap(boss.x, boss.y, 160, 160, playerX, playerY, 40, 40)) {
        playerHP -= 20 * (1 - damageReduction);

        updateHP();

        // odpychanie gracza aby nie utknƒÖ≈Ç w bossie
        playerX += (Math.random() * 60 - 30);
        playerY += (Math.random() * 60 - 30);
        updatePlayerPosition();

        boss.hasPoppedHit = true;
    }
}

        }
        return;
    }

    // ============================
    // 2) WYB√ìR ATAKU
    // ============================
    if (boss.attackTimer >= boss.attackCooldown) {
        boss.attackTimer = 0;

        if (Math.random() < 0.5) {
            antlionKingBurrowAttack(boss);
        } else {
            antlionKingSandVortex(boss);
        }
    }
}
function antlionKingBurrowAttack(boss) {
    boss.burrowed = true;
    boss.burrowTimer = 1500 + Math.random() * 800; // 1.5‚Äì2.3 sek
}
function antlionKingSandVortex(boss) {
    const range = 260;

    const f = document.createElement("div");
    f.style.position = "absolute";
    f.style.width = (range * 2) + "px";
    f.style.height = (range * 2) + "px";
    f.style.borderRadius = "50%";
    f.style.background = "rgba(180,140,40,0.35)";
    f.style.left = (boss.x + 80 - range) + "px";
    f.style.top  = (boss.y + 80 - range) + "px";
    f.style.zIndex = 3;

    world.appendChild(f);

    const centerX = boss.x + 80;
    const centerY = boss.y + 80;

    let damageTimer = 0;

    boss.vortexInterval = setInterval(() => {


    if (boss.dead || !boss.el) {
        clearInterval(boss.vortexInterval);
        boss.vortexInterval = null;
        return;
    }



        const dx = (centerX - (playerX + 20));
        const dy = (centerY - (playerY + 20));
        const dist = Math.hypot(dx, dy);

        if (dist < range) {
            const pullX = (dx / dist) * 1.3;
            const pullY = (dy / dist) * 1.3;

            playerX += pullX;
            playerY += pullY;
            updatePlayerPosition();

            damageTimer += 40;
            if (damageTimer >= 1500) {
                playerHP -= 1 * (1 - damageReduction);

                updateHP();
                damageTimer = 0;
            }
        }

    }, 40);

    // pole znika po 4 sekundach
    setTimeout(() => {
    if (boss.vortexInterval) {
        clearInterval(boss.vortexInterval);
        boss.vortexInterval = null;
    }
    f.remove();
}, 4000);

}
function giveRandomSpellReward() {
    const spell = RANDOM_SPELL_POOL[
        Math.floor(Math.random() * RANDOM_SPELL_POOL.length)
    ];

    const menu = document.getElementById("rewardMenu");

    // üî• wyczy≈õƒá TYLKO zawarto≈õƒá, menu zostaje
    menu.innerHTML = "";

    const title = document.createElement("h2");
    title.textContent = "Losowy czar!";
    menu.appendChild(title);

    const info = document.createElement("p");
    info.textContent = "Wybierz slot:";
    menu.appendChild(info);

    for (let s = 1; s <= 3; s++) {
        const btn = document.createElement("div");
        btn.className = "shopItem";
        btn.textContent = `Slot ${s} (teraz: ${spellsInSlots[s] || "pusty"})`;

       btn.onclick = () => {
    spellsInSlots[s] = spell;
    document.querySelector(`#slot${s} img`).src = spell;

    menu.style.display = "none";

    // üî• POJAWIA SIƒò PORTAL JAK PO KA≈ªDYM BOSSIE
    spawnPortal(ROOM_W / 2, ROOM_H / 2);
};


        menu.appendChild(btn);
    }

    menu.style.display = "block";
}



function giveRandomItemReward() {
  const ITEM_POOL = [
    "catfriend.png",
    AMULET_SLIME,
    ITEM_PUDDING,
    ITEM_POISON
];



    const item = ITEM_POOL[
        Math.floor(Math.random() * ITEM_POOL.length)
    ];

    const added = addItem(item);

    if (added && item === "catfriend.png") {
        spawnCatFollower();
    }
}


function spawnDarkForestTrees() {
    currentTrees = [];

    const treeCount = Math.floor(Math.random() * 3) + 2; // 2‚Äì4 drzewa

    for (let i = 0; i < treeCount; i++) {
        const tile = currentWalkable[
            Math.floor(Math.random() * currentWalkable.length)
        ];

        const x = tile.x1 + TILE_SIZE/2 - 80;
        const y = tile.y1 + TILE_SIZE/2 - 80;

        const tree = document.createElement("div");
        tree.className = "tree2";
        tree.style.left = x + "px";
        tree.style.top  = y + "px";

        world.appendChild(tree);

        currentTrees.push({
            el: tree,
            x1: x,
            y1: y,
            x2: x + 160,
            y2: y + 160
        });
    }
}
function destroyBoss(boss) {

    // üî• usu≈Ñ przyzwa≈Ñc√≥w Slime Kinga
    if (boss.bossType === "slimeKing" && boss.summonedSlimes) {
        boss.summonedSlimes.forEach(s => {
            if (s.el) s.el.remove();
            if (s.hpBar) s.hpBar.remove();
            if (currentEnemies.includes(s)) {
                currentEnemies.splice(currentEnemies.indexOf(s), 1);
            }
        });
        boss.summonedSlimes = [];
    }

    boss.dead = true;

    if (boss.vortexInterval) {
        clearInterval(boss.vortexInterval);
        boss.vortexInterval = null;
    }

    if (boss.field) {
        boss.field.remove();
        boss.field = null;
    }

    if (boss.particleEl) {
        boss.particleEl.remove();
        boss.particleEl = null;
    }
}

function spawnSlimeKingBoss(x, y) {
    const boss = document.createElement("div");
    boss.className = "enemy boss";
    boss.style.width = "160px";
    boss.style.height = "160px";
    boss.style.background = "url('boss6.png') center/contain no-repeat";
    boss.style.left = x + "px";
    boss.style.top  = y + "px";

    world.appendChild(boss);

    currentEnemies.push({
        el: boss,
        x: x,
        y: y,
        hp: 260,
        maxHP: 260,
        isBoss: true,
        bossType: "slimeKing",

        // SLIME MECHANIKA
        jumpTimer: 0,
        jumpCooldown: 2500,     // szybszy ni≈º zwyk≈Çy slime
        jumpTarget: null,
        warningEl: null,
        falling: false,

        // PRZYZYWANIE
        summonCooldown: 6000,
        summonTimer: 0,
        summonedSlimes: []     // ‚≠ê zapamiƒôtujemy przyzwanych
    });
}
function updateSlimeKingBoss(boss, delta) {

    // ===== SKOK JAK SLIME =====
    boss.jumpTimer += delta;

    if (!boss.falling && !boss.warningEl && boss.jumpTimer >= boss.jumpCooldown) {
        boss.jumpTimer = 0;

        const tx = playerX + 20;
        const ty = playerY + 20;
        boss.jumpTarget = { x: tx, y: ty };

        const warn = document.createElement("div");
        warn.style.position = "absolute";
        warn.style.width = "180px";   // ‚≠ê wiƒôkszy zasiƒôg
        warn.style.height = "180px";
        warn.style.borderRadius = "50%";
        warn.style.background = "rgba(255,0,0,0.35)";
        warn.style.left = (tx - 90) + "px";
        warn.style.top  = (ty - 90) + "px";
        warn.style.zIndex = 2;

        world.appendChild(warn);
        boss.warningEl = warn;

        setTimeout(() => {
            if (boss.dead) return;

            boss.falling = true;
            boss.x = tx - 80;
            boss.y = -200;
            boss.el.style.left = boss.x + "px";
            boss.el.style.top  = boss.y + "px";

            warn.remove();
            boss.warningEl = null;
        }, 1500);
    }

    if (boss.falling) {
        boss.y += 20;
        boss.el.style.top = boss.y + "px";

        if (boss.y >= boss.jumpTarget.y - 80) {
            boss.falling = false;

            if (rectsOverlap(
                boss.x, boss.y, 160, 160,
                playerX, playerY, 40, 40
            )) {
                playerHP -= 18 * (1 - damageReduction);

                updateHP();
            }
        }
    }

    // ===== PRZYZYWANIE SLIMA =====
    boss.summonTimer += delta;

if (
    !boss.falling &&
    !boss.warningEl &&
    boss.summonTimer >= boss.summonCooldown &&
    boss.summonedSlimes.length < 2   // ‚≠ê LIMIT
) {
    boss.summonTimer = 0;
    summonSlimeForBoss(boss);
}


}
function summonSlimeForBoss(boss) {

    // napis
    const text = document.createElement("div");
    text.textContent = "Boss wezwa≈Ç posi≈Çki!";
    text.style.position = "absolute";
    text.style.left = (boss.x + 40) + "px";
    text.style.top  = (boss.y - 40) + "px";
    text.style.color = "rgba(255,255,255,0.7)";
    text.style.fontSize = "20px";
    text.style.zIndex = 50;

    world.appendChild(text);
    setTimeout(() => text.remove(), 1200);

    // spawn zwyk≈Çego slima
    const slimeType = ENEMY_TYPES[8]; // zwyk≈Çy slime

    const ex = boss.x + Math.random() * 120 - 60;
    const ey = boss.y + Math.random() * 120 - 60;

  const enemy = document.createElement("div");
enemy.className = "enemy";
enemy.style.background = `url("${slimeType.img}") center/cover no-repeat`;
enemy.style.left = ex + "px";
enemy.style.top  = ey + "px";

// === HP BAR ===
const hpBar = document.createElement("div");
hpBar.style.position = "absolute";
hpBar.style.width = "40px";
hpBar.style.height = "6px";
hpBar.style.background = "red";
hpBar.style.border = "1px solid #000";
hpBar.style.left = ex + "px";
hpBar.style.top  = (ey - 10) + "px";
hpBar.style.zIndex = 9;

const hpFill = document.createElement("div");
hpFill.style.width = "100%";
hpFill.style.height = "100%";
hpFill.style.background = "lime";

hpBar.appendChild(hpFill);

world.appendChild(enemy);
world.appendChild(hpBar);


 const slimeObj = {
    el: enemy,
    x: ex,
    y: ey,
    hp: slimeType.maxHP,
    type: slimeType,

    hpBar: hpBar,      // ‚≠ê KLUCZOWE
    hpFill: hpFill,    // ‚≠ê KLUCZOWE

    warn: null,
    attackTimer: 0,
    attackCharging: false,

    jumpTimer: 0,
    jumpCooldown: slimeType.jumpCooldownOverride || 3000,

    lastDamageTime: 0,
    isSummoned: true
};


    currentEnemies.push(slimeObj);
    boss.summonedSlimes.push(slimeObj);
}
function addItem(itemIcon) {
    if (magicItems.includes(itemIcon)) return false;

    magicItems.push(itemIcon);
    updateItemHUD();

    if (itemIcon === AMULET_SLIME) {
        applyAmuletSlime();
    }
if (itemIcon === ITEM_POISON) {
    poisonShots = true;
}

    if (itemIcon === ITEM_PUDDING) {
        applyPudding();
    }

    return true;
}



const AMULET_SLIME = "amulet_slime.png";
function applyAmuletSlime() {
    enemySpeedMultiplier = 0.9; // -10%
}
document.getElementById("buySlimeAmulet").onclick = () => {
    if (!shopOpen) return;

    if (gold < 50) {
        alert("Za ma≈Ço z≈Çota!");
        return;
    }

    const added = addItem(AMULET_SLIME);
    if (!added) {
        alert("Ju≈º masz ten amulet!");
        return;
    }

    gold -= 50;
    updateGold();
    closeShop();
};
function spawnTraderHere(type) {
    const tile = currentWalkable[Math.floor(Math.random() * currentWalkable.length)];
    const x = tile.x1 + TILE_SIZE/2 - 20;
    const y = tile.y1 + TILE_SIZE/2 - 20;

    const t = document.createElement("div");
    t.className = type === "pudding" ? "traderPudding" : "trader";
    t.style.left = x + "px";
    t.style.top  = y + "px";

    world.appendChild(t);
    currentTrader = { el: t, x, y, type };
}
function rollTradersForFloor() {
    normalTraderWillSpawn = Math.random() < 1;
    puddingTraderWillSpawn = Math.random() < 0.3;

    // ü¶Ç HANDLARZ PUSTYNNY ‚Äî TYLKO NA PUSTYNI
    if (worldType === "desert") {
        desertTraderWillSpawn = Math.random() < 0.7; // 70%
    } else {
        desertTraderWillSpawn = false;
    }

    desertTraderSpawned = false;
    desertTraderRoom = null;
}

function applyPudding() {
    enemyProjectileSpeedMultiplier = 0.7; // üî• -30%
}
document.getElementById("buyPudding").onclick = () => {
    if (!shopOpen) return;

    if (gold < 150) {
        alert("Za ma≈Ço z≈Çota!");
        return;
    }

    const added = addItem(ITEM_PUDDING);
    if (!added) {
        alert("Ju≈º masz pudding!");
        return;
    }

    gold -= 150;
    updateGold();
    closeShop();
};
document.getElementById("buyJellySpell").onclick = () => {
    if (!shopOpen) return;

    if (gold < 120) {
        alert("Za ma≈Ço z≈Çota!");
        return;
    }

    const cont = document.getElementById("shopSlots");
    cont.innerHTML = "<h3>Wybierz slot na GalaretowƒÖ Tarczƒô:</h3>";

    for (let s = 1; s <= 3; s++) {
        const btn = document.createElement("div");
        btn.className = "shopItem";
        btn.textContent = `Slot ${s} (teraz: ${spellsInSlots[s] || "pusty"})`;

        btn.onclick = () => {
            gold -= 120;
            updateGold();

            spellsInSlots[s] = "czar5.png";
            document.querySelector(`#slot${s} img`).src = "czar5.png";

            closeShop();
        };

        cont.appendChild(btn);
    }
};
function spawnForestChargerBoss(x, y) {
    const boss = document.createElement("div");
    boss.className = "enemy boss";
    boss.style.width = "160px";
    boss.style.height = "160px";
    boss.style.background = "url('boss7.png') center/contain no-repeat";
    boss.style.left = x + "px";
    boss.style.top  = y + "px";

    world.appendChild(boss);

currentEnemies.push({
    el: boss,
    x: x,
    y: y,

    hp: 180,
    maxHP: 180,

    isBoss: true,
    bossType: "forestCharger",

    chargeDir: 1,
    chargeSpeed: 14,
    chargeTime: 0,
    chargeDuration: 900,
    pauseTime: 0,
    pauseDuration: 3000,

    hasHitThisCharge: false   // ‚≠ê NOWE
});

}
function updateForestChargerBoss(boss, delta) {

    // ‚è∏Ô∏è PRZERWA PO SZAR≈ªY
    if (boss.pauseTime > 0) {
        boss.pauseTime -= delta;
        return;
    }

    boss.chargeTime += delta;

    // ‚û°Ô∏è RUCH POZIOMY
    boss.x += boss.chargeDir * boss.chargeSpeed;
    boss.el.style.left = boss.x + "px";



    // üí• KOLIZJA Z GRACZEM
  if (
    !boss.hasHitThisCharge &&
    rectsOverlap(
        boss.x, boss.y, 160, 160,
        playerX, playerY, 40, 40
    )
) {
    playerHP -= 14 * (1 - damageReduction);
    updateHP();
    boss.hasHitThisCharge = true; // ‚≠ê BLOKADA
}


  // ‚è±Ô∏è KONIEC SZAR≈ªY
if (boss.chargeTime >= boss.chargeDuration) {
    boss.chargeTime = 0;
    boss.pauseTime = boss.pauseDuration;
    boss.hasHitThisCharge = false;

    // üìè oblicz odleg≈Ço≈õƒá do krawƒôdzi
    const distLeft  = boss.x;
    const distRight = ROOM_W - (boss.x + 160);

    // ‚û°Ô∏è zawsze szar≈ºuje w stronƒô dalszej krawƒôdzi
    if (distLeft > distRight) {
        boss.chargeDir = -1; // dalej do lewej
        boss.x = ROOM_W - 160;
    } else {
        boss.chargeDir = 1;  // dalej do prawej
        boss.x = 0;
    }

    // üéØ losowa wysoko≈õƒá
    const minY = 0;
    const maxY = ROOM_H - 160;
    boss.y = minY + Math.random() * (maxY - minY);

    boss.el.style.left = boss.x + "px";
    boss.el.style.top  = boss.y + "px";
}

    }
function spawnDesertTraderHere() {
    const tile = currentWalkable[
        Math.floor(Math.random() * currentWalkable.length)
    ];

    const x = tile.x1 + TILE_SIZE / 2 - 32;
    const y = tile.y1 + TILE_SIZE / 2 - 32;

    const t = document.createElement("div");
    t.className = "desertTrader";
    t.style.left = x + "px";
    t.style.top  = y + "px";

    world.appendChild(t);

    currentTrader = { el: t, x, y, type: "desert" };
}

const ITEM_POISON = "poisonpotion.png";
let poisonShots = false;
document.getElementById("buyPoisonPotion").onclick = () => {
    if (!shopOpen) return;

    if (gold < 60) {
        alert("Za ma≈Ço z≈Çota!");
        return;
    }

    const added = addItem(ITEM_POISON);
    if (!added) {
        alert("Ju≈º masz ten item!");
        return;
    }

    gold -= 60;
    updateGold();
    closeShop();
};







</script>
</body>
</html>
